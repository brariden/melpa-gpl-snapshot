\newcommand{\net}[0]{{\tt .NET}}
\newcommand{\kw}[1]{{\textcolor{kwcolor}{\tt #1}}}
\newcommand{\ra}{\texttt{ -> }}

\definecolor{kwcolor}{rgb}{0.2,0.4,0.0}
\definecolor{lgray}{rgb}{0.8,0.8,0.8}

\title{Rekonstrukcja typów z odraczaniem}
\author{Micha{\l} Moskal}
\institute{Zimowy Obóz Studentów Informatyki \\
Szklarska Porêba}
\date{18 marca 2005}


\begin{document}

\section{Zaczynamy!}

\frame{\titlepage}

\frame{
\frametitle{Nemerle? A co to takiego?}
\begin{itemize}
  \item jêzyk programowania wysokiego poziomu
  \item ogólnego przeznaczenia
  \item od pocz±tku projektowany z my¶l± o \net
  \item funkcjonalny i obiektowy
  \item potê¿ny system metaprogramowania
\end{itemize}
}

\frame{
\frametitle{Po co to to?}

\begin{itemize}
  \item chcieli¶my po³±czyæ programowanie obiektowe (w sensie C\#) z programowaniem
        funkcjonalnym
\begin{itemize}
 \item podstawowa struktura programu jest obiektowa
 \item metody w ¶rodku zaimplementowane funkcjonalnie
 \item<+-> ³atwy dostêp do cech imperatywnych (operator \texttt{!})
\end{itemize}
  \item<+-> u¿ywanie ró¿nych funkcjonalno¶ci platformy \net\ jest znacznie ³atwiejsze
        w C\# ni¿ w adaptacjach istniej±cych jêzyków funkcjonalnych
  \item<+-> nacisk na ³atwe utrzymanie kodu (makra, rekonstrukcja typów)
  \item<+-> makra!
    
\end{itemize}
}
\frame{
\frametitle{Projekty}

\begin{itemize}
  \item<+-> serwer HTTP i aplikacji Sioux
  \item<+-> system przepisywania termów Speagram
  \item<+-> konwerter C\# \texttt{->} Nemerle
  \item<+-> kompilator :-)
\end{itemize}
}


\section{Wszyscy lubimy przyk³ady}

\frame[containsverbatim]{
\frametitle{Cze¶æ}

\begin{verbatim}
// typy po prawej i po :
class Hello {
  public static Main () : void
  {
    System.Console.Write ("Hello world!\n");
  }
}
\end{verbatim}
}


\frame[containsverbatim]{
\frametitle{Brak rekonstrukcji}
\begin{verbatim}
// C#
public static void SendMessage (byte[] addr, int port, 
                                string data)
{
  IPEndPoint ip = new IPEndPoint (new IPAddress (addr), port);
  TcpClient client = new TcpClient (ip);
  NetworkStream str = client.GetStream ();
  byte[] data = Encoding.UTF8.GetBytes (data);
  str.Write (data, 0, data.Length);
  client.Close ();
}
\end{verbatim}
}

\frame[containsverbatim]{
\frametitle{Rekonstrukcja}
\begin{verbatim}
// Nemerle
public static SendMessage (addr : array [byte],
                           port : int, data : string) : void
{
  def ip = IPEndPoint (IPAddress (addr), port);
  def client = TcpClient (ip);
  def str = client.GetStream ();
  def data = Encoding.UTF8.GetBytes (data);
  str.Write (data, 0, data.Length);
  client.Close ();
}
\end{verbatim}
}


\frame[containsverbatim]{
\frametitle{Brak rekonstrukcji II}
\begin{verbatim}
public static
Dictionary<string, int> CountEach (string[] args)
{
  Dictionary<string, int> d = new Dictionary<string, int>();
  foreach (string s in args) {
    if (d.ContainsKey (s))
      d[s] += 1;
    else
      d[s] = 1;
  }
  return d;
}
\end{verbatim}
}

\frame[containsverbatim]{
\frametitle{Rekonstrukcja II}
\begin{verbatim}
public static
CountEach (args : array [string]) : Dictionary [string, int]
{
  def d = Dictionary ();
  foreach (s in args) {
    if (d.ContainsKey (s))
      d[s] += 1;
    else
      d[s] = 1;
  }
  d
}
\end{verbatim}
}


\section{Funkcje lokalne}

\frame[containsverbatim]{
\frametitle{To proste :-)}
\begin{verbatim}
static SomeFun (x : Foo, y : int) : int { ... }

public static
SomeFunOnList (args : list [Foo]) : list [int]
{
  def call_some (x : Foo) : int {
    SomeFun (x, 3)
  }

  List.Map (args, call_some)
}
\end{verbatim}
}



\frame[containsverbatim]{
\frametitle{Teraz z rekonstrukcj±}
\begin{verbatim}
static SomeFun (x : Foo, y : int) : int { ... }

public static
SomeFunOnList (args : list [Foo]) : list [int]
{
  def call_some (x) {
    SomeFun (x, 3)
  }

  List.Map (args, call_some)
}
\end{verbatim}
}



\frame[containsverbatim]{
\frametitle{Trochê krócej}
\begin{verbatim}
static SomeFun (x : Foo, y : int) : int { ... }

public static
SomeFunOnList (args : list [Foo]) : list [int]
{
  List.Map (args, fun (x) { SomeFun (x, 3) })
}
\end{verbatim}
}


\frame[containsverbatim]{
\frametitle{To tylko skrót}
\begin{verbatim}
static SomeFun (x : Foo, y : int) : int { ... }

public static
SomeFunOnList (args : list [Foo]) : list [int]
{
  List.Map (args, { def tmp (x) { SomeFun (x, 3) }; tmp })
}
\end{verbatim}
}


\section{¦wiat to jednak paskudne miejsce}

\frame[containsverbatim]{
\frametitle{Zaczynaj± siê schody}
\begin{verbatim}
static SomeFun (x : Foo, y : int) : int { ... }
static SomeFun (x : Bar, y : int) : int { ... }

public static
SomeFunOnList (args : list [Foo]) : list [int]
{
  def call_some (x) {
    SomeFun (x, 3) // oops
  }

  List.Map (args, call_some)
}
\end{verbatim}
}

\frame{
\frametitle{Przeci±¿anie jest dla miêczaków!}
\begin{itemize}
  \item<+->
mo¿emy przecie¿ kazaæ u¿ytkownikowi zamist dwa
razy {\tt SomeFun} napisaæ {\tt SomeFun\_Foo}
oraz {\tt SomeFun\_Bar}! 
\item<+-> przecie¿ w Eiffel.NET tak w³a¶nie jest, hmm...
\item<+->
{\tt Console.WriteLine\_System\_String\_System\_Object\_Sys\-tem\_Object("ala~ma~\{0\}~kotów~i~\{1\}~psów",~5,~7);}
\item<+-> ale to nie jedyny problem...
\end{itemize}
}


\frame[containsverbatim]{
\frametitle{Niedobra kropka!}
\begin{verbatim}
public static
SomeMethodOnList (args : list [Foo]) : list [int]
{
  def call_some (x) {
    x.SomeMethod (3) // oops
  }

  List.Map (args, call_some)
}
\end{verbatim}
}

\frame{
\frametitle{Yyyyy, to mo¿e...}
\begin{itemize}
  \item<+-> zabroniæ metod o tej samej nazwie w wiêcej ni¿ jednej
        klasie?
  \item<+-> ale co z bibliotek±?
  \item<+-> poza tym chcieliby¶my {\tt args.Map (call\_some)} zamiast \\
          {\tt List.Map (args, call\_some)}
\end{itemize}
}



\frame{
\frametitle{Nienazwane typy?}
\begin{itemize}
  \item<+-> mo¿e przy wywo³aniu nadaæ {\tt x} typ wszystkie--klasy--z--metod±--{\tt SomeMethod}?
  \item<+-> ale pozostaje problem z przeci±¿aniem
  \item<+-> konwersje niejawne w ogóle nierabialne
\end{itemize}
}




\section{Rozwi±zanie!}

\frame{
\frametitle{Co masz zrobiæ dzi¶, zrób pojutrze!}
\begin{itemize}
  \item<+-> mo¿emy odroczyæ typowanie {\tt x} a¿ wiêcej siê o nim dowiemy
  \item<+-> podobnie mo¿emy zrobiæ z przeci±¿onymi wywo³aniami
  \item<+-> ale...
  \item<+-> je¶li to takie proste, to czemu nikt tego wcze¶niej nie robi³?
\end{itemize}
}


\frame{
\frametitle{Znowu k³opoty...}
\begin{itemize}
  \item<+-> wymagamy globalnego rozwi±zywania wiêzów na typach
  \begin{itemize}
  \item<+-> co jest ogólnie uznawane za nieefektywne
  \item<+-> ciê¿ko podaæ dobry komunikat b³êdu
  \item<+-> ciekawostka -- czy wiecie, ¿e ponad po³owa porz±dnego
            kompilatora zwi±zana jest ze zg³aszaniem b³êdów?
  \end{itemize}
  \item<+-> w trakcie typowania mamy niepe³n± informacjê
  \item<+-> algorytm typowania musi byæ odporny na braki informacji
            i zawsze zak³adaæ, ¿e mo¿e kiedy¶ bêdzie co¶ wiadomo
\end{itemize}
}


\section{Wiêzy na typach}

\frame{
\frametitle{Podtypowanie}
\begin{itemize}
  \item<+-> mamy dwie klasy A oraz B, gdzie A dziedziczy po B
  \item<+-> czyli dla ka¿dy obiekt klasy A jest równie¿ obiektem
        klasy B, ale nie koniecznie odwrotnie
  \item<+-> o typach A i B mo¿na my¶leæ jak o zbiorach warto¶ci (obiektów)
  \item<+-> wtedy ³atwo zauwa¿yæ, ¿e $B \subseteq A$
  \item<+-> w teorii typów piszemy, ¿e $B <: A$.
\end{itemize}
}

\frame{
\frametitle{Problem z polimorfizmem i podtypowaniem}
\begin{itemize}
  \item<+-> we¼my funkcjê {\tt Compare[$\alpha$] (x : $\alpha$, y : $\alpha$) : bool}
  \item<+-> oraz wywo³anie {\tt Compare (create\_A (), create\_B ())}
  \item<+-> je¶li podamy jawnie {\tt Compare[A] (create\_A (), create\_B ())}
    \begin{itemize}
      \item typ metody zmieni siê na {\tt Compare (x : A, y : A) : bool},
      \item pierwszy argument bêdzie pasowa³ od razu,
      \item a drugi po niejawnej konwersji w górê.
    \end{itemize}
\end{itemize}
}


\frame{
\frametitle{Jawne parametry typowe s± nie³adne}
\begin{itemize}
  \item<+-> nie chcemy podawaæ jawnie parametrów typowych
  \item<+-> dlatego w miejscu wywo³ania rozwi±zujemy uk³ad nierówno¶ci
            na typach: \\
	\[
	  \left\{ \begin{array}{l}A <: \alpha \\B <: \alpha\end{array} \right.
	\]
  \item<+-> którego najbardziej szczegó³owym rozwi±zaniem jest $\alpha = A$
\end{itemize}
}

\frame{
\frametitle{Lokalne i globalne wiêzy}
\begin{itemize}
  \item<+-> wiêzy na typach mo¿emy traktowaæ lokalnie lub globalnie
  \item<+-> mo¿emy je próbowaæ rozwi±zaæ od razu w miejscu wywo³ania funkcji,
            w razie problemów zg³aszaj±c b³±d (lokalnie)
  \item<+-> lub pozbieraæ z ca³ego programu (lub fragmentu, który akurat typujemy)
            i próbowaæ rozwi±zaæ na koniec (globalnie)
  \item<+-> globalne podej¶cie pozwala na zebranie wiêkszej ilo¶ci informacji,
            kompilator jest wiêc bardziej domy¶lny,
  \item<+-> tylko, je¶li co¶ siê nie uda, to sk±d wiedzieæ co to by³o?
\end{itemize}
}


\frame{
\frametitle{Wiêzy on--line}
\begin{itemize}
  \item<+-> my jednak zrobimy co¶ po¶redniego,
  \item<+-> próbujemy z ka¿dego dodanego wiêzu wyci±gn±æ maximum informacji
            od razu,
  \item<+-> zostawiaj±c jednak wszelkie niejasno¶ci na pó¼niej
\end{itemize}
}


\frame{
\frametitle{Graf zmiennych}
\begin{itemize}
  \item<+-> na zmienne wraz z ³±cz±cymi je relacjami podtypowania patrzymy jako na graf
  \item<+-> graf jest przechodnio--domkniêty (je¶li $\alpha <: \beta \;\wedge\;
    \beta<:\gamma$ to $\alpha <: \gamma$)
  \item<+-> ka¿dy wierzcho³ek ma górn± i doln± granicê, która nie jest zmienn±
  \item<+-> mo¿emy o te granice zapytaæ solver
\end{itemize}
}

\frame{
\frametitle{Graf zmiennych II}
\begin{itemize}
  \item<+-> cykle s± ³±czone -- graf jest DAGiem
  \item<+-> dla ka¿dego wierzcho³ka $\alpha$ \\
    $\alpha^{\uparrow} <: \alpha_{\downarrow}$
  \item<+-> oraz je¶li $\alpha <: \beta$ jest krawêdzi± to \\
    $\alpha^{\uparrow} <: \beta^{\uparrow} \;\wedge\;
    \alpha_{\downarrow} <: \beta_{\downarrow}$
  \item<+-> je¶li $\alpha^{\uparrow}$ oraz $\alpha_{\downarrow}$
      siê zejd± to unifikujemy
  \item<+-> je¶li dodajemy $\tau <: \alpha$ to robimy
     $\alpha^{\uparrow} := \alpha^{\uparrow} \cup \tau$
  \item<+-> je¶li dodajemy $\alpha <: \tau$ to robimy
     $\alpha_{\downarrow} := \alpha_{\downarrow} \cap \tau$
\end{itemize}
}

\frame{
\frametitle{Inne problemy}
\begin{itemize}
  \item<+-> stan solvera musi byæ mo¿liwy do zapamiêtania i odtworzenia
  \item<+-> kilka zmiennych typowych na bajt kodu ¼ród³owego -- solver musi
byæ efektywny
\end{itemize}
}


\section{To jest ju¿ koniec}
\frame{
\frametitle{Podsumowanie}
\begin{itemize}
  \item<+-> typowanie z globalnym rozwi±zywaniem wiêzów wcale nie musi byæ
            nieefektywne 
  \item<+-> nie musi te¿ dawaæ dziwnych komunikatów o b³êdach
  \item<+-> rekonstrukcja typów mo¿e dzia³aæ w niesprzyjaj±cych warunkach
\end{itemize}
}



\end{document}

% vim: language=polish
