;;; logview.el --- Major mode for viewing log files  -*- lexical-binding: t -*-

;; Copyright (C) 2015 Paul Pogonyshev

;; Author:     Paul Pogonyshev <pogonyshev@gmail.com>
;; Maintainer: Paul Pogonyshev <pogonyshev@gmail.com>
;; Version:    0.4.2
;; Keywords:   files, tools
;; Homepage:   https://github.com/doublep/logview
;; Package-Requires: ((emacs "24.1"))

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation, either version 3 of
;; the License, or (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see http://www.gnu.org/licenses.


;;; Commentary:

;; Logview mode provides syntax highlighting, filtering and other
;; features for various log files.  The main target are files similar
;; to ones generated by Log4j, Logback and other Java logging
;; libraries, but there is really nothing Java-specific in the mode
;; and it should work just fine with any log that follows similar
;; structure, probably after some configuration.


;;; Code:

(eval-when-compile (require 'cl-lib))

;; We _append_ self to the list of mode rules so as to not clobber
;; other rules, as '.log' is a common file extension.  This also gives
;; the user an easy way to prevent 'logview' from being autoselected.
;;;###autoload
(add-to-list 'auto-mode-alist '("\\.log\\(?:\\.[0-9]+\\)?\\'" . logview-mode) t)



;;; Public variables.
;; This needs to go before customization, since the values are used in
;; compound widget types.

(defvar logview-std-submodes
  '(("SLF4J" . ((format  . "TIMESTAMP [THREAD] LEVEL NAME -")
                (levels  . "SLF4J")
                (aliases . ("Log4j" "Log4j2" "Logback"))))
    ;; We misuse thread as a field for hostname.
    ("UNIX"  . ((format  . "TIMESTAMP THREAD NAME:"))))
  "Alist of standard submodes.
This value is used as the fallback for customizable
`logview-additional-submodes'.")

(defvar logview-std-level-mappings
  '(("SLF4J" . ((error       "ERROR")
                (warning     "WARN")
                (information "INFO")
                (debug       "DEBUG")
                (trace       "TRACE")
                (aliases     "Log4j" "Log4j2" "Logback")))
    ("JUL"   . ((error       "SEVERE")
                (warning     "WARNING")
                (information "INFO")
                (debug       "CONFIG" "FINE")
                (trace       "FINER" "FINEST"))))
  "Standard mappings of actual log levels to mode's final levels.
This alist value is used as the fallback for customizable
`logview-additional-level-mappings'.")

(defvar logview-std-timestamp-formats
  ;; General notices: we silently handle both common decimal
  ;; separators (dot and comma).  In several cases there is optional
  ;; space if the day/hour number is single-digit.
  (let ((HH:mm:ss          "[012][0-9]:[0-5][0-9]:[0-5][0-9]")
        (h:mm:ss           "[ 01]?[0-9]:[0-5][0-9]:[0-5][0-9]")
        (.SSS              "[.,][0-9]\\{3\\}")
        (a                 " [AP]M")
        (yyyy-MM-dd        "[0-9]\\{4\\}-[01][0-9]-[0-3][0-9]")
        (MMM               (regexp-opt '("Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec")))
        (d                 "[ 1-3]?[0-9]")
        )
    (list (list "ISO 8601 datetime + millis"
                (cons 'regexp  (concat yyyy-MM-dd " " HH:mm:ss .SSS))
                (list 'aliases "yyyy-MM-dd HH:mm:ss.SSS"))
          (list "ISO 8601 datetime"
                (cons 'regexp  (concat yyyy-MM-dd " " HH:mm:ss))
                (list 'aliases "yyyy-MM-dd HH:mm:ss"))
          (list "ISO 8601 time only + millis"
                (cons 'regexp  (concat HH:mm:ss .SSS))
                (list 'aliases "HH:mm:ss.SSS"))
          (list "ISO 8601 time only"
                (cons 'regexp  HH:mm:ss)
                (list 'aliases "HH:mm:ss"))
          (list "MMM d HH:mm:ss"
                (cons 'regexp  (concat MMM " " d " " HH:mm:ss)))
          (list "MMM d h:mm:ss a"
                (cons 'regexp  (concat MMM " " d " " h:mm:ss a)))
          (list "h:mm:ss a"
                (cons 'regexp  (concat h:mm:ss a)))))
  "Alist of standard timestamp formats.
This value is used as the fallback for customizable
`logview-additional-timestamp-formats'.")



;;; Customization.

(defgroup logview nil
  "Log viewing mode."
  :group 'text)


(defun logview--set-submode-affecting-variable (variable value)
  (set variable value)
  (dolist (buffer (buffer-list))
    (with-current-buffer buffer
      (when (and (eq major-mode 'logview-mode) (not (logview-initialized-p)))
        (logview--guess-submode)))))

(defvar logview--additional-submodes-type
  (let* ((italicize      (lambda (string) (propertize string 'face 'italic)))
         (mapping-option (lambda (mapping)
                           (let ((name    (car mapping))
                                 (aliases (cdr (assq 'aliases (cdr mapping)))))
                             (list 'const
                                   :tag (if aliases
                                            (format "%s (aka: %s)" (funcall italicize name) (mapconcat italicize aliases ", "))
                                          (funcall italicize name))
                                   name)))))
    (list 'repeat (list 'cons '(string :tag "Name")
                        (list 'list :tag "Definition"
                              '(cons :tag "" (const :tag "Format:" format) string)
                              (list 'set :inline t
                                    (list 'cons :tag "" '(const :tag "Level map:" levels)
                                          (append '(choice)
                                                  (mapcar mapping-option logview-std-level-mappings)
                                                  '((string :tag "Other name"))))
                                    (list 'cons :tag "" '(const :tag "Timestamp:" timestamp)
                                          (list 'choice
                                                '(const :tag "Any supported" nil)
                                                (list 'repeat
                                                      (append '(choice)
                                                              (mapcar mapping-option logview-std-timestamp-formats)
                                                              '((string :tag "Other name"))))))
                                    '(cons :tag "" (const :tag "Aliases:"   aliases)   (repeat string))))))))

(defcustom logview-additional-submodes nil
  "Association list of log submodes (file parsing rules).

A few common submodes are already defined by the mode in variable
`logview-std-submodes', but the ones you add here always take
precedence.

Submode definition has one required and several optional fields:

format

    The only mandatory and the most important field that defines
    how log entries are built from pieces.  There are currently
    four such supported pieces: \"TIMESTAMP\", \"LEVEL\", \"NAME\"
    and \"THREAD\".  All four are optional.  For example, Log4j,
    by default formats entries according to this pattern:

        TIMESTAMP [THREAD] LEVEL NAME -

levels  [may be optional]

    Level mapping (see `logview-additional-level-mappings') used
    for this submode.  This field is optional only if the submode
    lacks levels altogether.

    There are some predefined values valid for this field:
    \"SLF4J\" (and its alises \"Log4j\", \"Log4j2\", \"Logback\"
    and \"JUL\".  See variable `logview-std-level-mappings' for
    details.

timestamp  [optional]

    If set, must be a list of timestamp format names to try (see
    `logview-additional-timestamp-formats').  If not set or
    empty, all defined timestamp formats will be tried.

aliases  [optional]

    Submode can have any number of optional aliases, which work just
    as the name."
  :group 'logview
  :type  logview--additional-submodes-type
  :set   'logview--set-submode-affecting-variable
  :set-after '(logview-additional-timestamp-formats logview-additional-level-mappings))

(defcustom logview-additional-level-mappings nil
  "Association list of log level mappings.

A few common maps are already defined by the mode in variable
`logview-std-level-mappings', but the ones you add here always
take precedence.

Each mapping has a name, by which it is referred from submode
definition.  Mapping itself consists of five lists of strings:
error levels, warning levels, information levels, debug levels
and trace levels.  In these lists you should add all possible
real levels that can appear in log file, in descending order of
severity.

For example, for Java SLF4J (Log4j, Logback, etc.) the mapping
looks like this:

        Error levels:        ERROR
        Warning levels:      WARN
        Information levels:  INFO
        Trace levels:        TRACE
        Debug levels:        DEBUG

This is not a coincidence, as the mode is primarily targeted at
SLF4J log files.

However, mapping for JUL (java.util.logging) framework looks more
complicated:

        Error levels:        SEVERE
        Warning levels:      WARNING
        Information levels:  INFO
        Trace levels:        CONFIG, FINE
        Debug levels:        FINER, FINEST

JUL has seven severity levels and we need to map them to five the
mode supports.  So the last two lists contain two levels each.
It is also legal to have empty lists, usually if there are less
than five levels.

Mapping can have any number of optional aliases, which work just
as the name."
  :group 'logview
  :type  '(repeat (cons (string :tag "Name")
                        (list :tag "Definition"
                              (cons :tag "" (const :tag "Error levels:"       error)       (repeat string))
                              (cons :tag "" (const :tag "Warning levels:"     warning)     (repeat string))
                              (cons :tag "" (const :tag "Information levels:" information) (repeat string))
                              (cons :tag "" (const :tag "Debug levels:"       debug)       (repeat string))
                              (cons :tag "" (const :tag "Trace levels:"       trace)       (repeat string))
                              (set :inline t
                                   (cons :tag "" (const :tag "Aliases:" aliases) (repeat string))))))
  :set   'logview--set-submode-affecting-variable)

(defcustom logview-additional-timestamp-formats nil
  "Association list of additional timestamp formats.

A few common formats are already defined by the mode in variable
`logview-std-timestamp-formats', but the ones you add here always
take precedence.

Each format has a name, by which it can be referred from submode
definition.  A format is defined simply by a regular expression
timestamp must match.  It is strongly recommended to make the
expression as strict as possible to avoid false positives.  For
example, if you entered something like \"\\w+\" as an expression,
this would often lead to Logview mode autoselecting wrong submode
and thus parsing log files incorrectly.

Timestamp format can have any number of optional aliases, which
work just as the name."
  :group 'logview
  :type  '(repeat (cons (string :tag "Name")
                        (list :tag "Definition"
                              (cons :tag "" (const :tag "Format:"  regexp)  regexp)
                              (set :inline t
                                   (cons :tag "" (const :tag "Aliases:" aliases) (repeat string))))))
  :set   'logview--set-submode-affecting-variable)


(defcustom logview-auto-revert-mode nil
  "Automatically put recognized buffers into Auto-Revert mode.
Buffers for which no appropriate submode can be guessed are not
affected and buffers not associated with files.  Having this set
to \"Off\" doesn't prevent Global Auto-Revert mode from affecting
Logview buffers.

Whenever new text is added to the buffer, it is automatically
parsed, highlighted and all currently active filters are applied
to it.

To temporarily activate or deactivate Auto-Revert (Tail) mode in
a Logview buffer type \\<logview-mode-map>\\[auto-revert-mode] or \\<logview-mode-map>\\[auto-revert-tail-mode]."
  :group 'logview
  :type  '(choice (const :tag "Off"                   nil)
                  (const :tag "Auto-Revert mode"      auto-revert-mode)
                  (const :tag "Auto-Revert Tail mode" auto-revert-tail-mode)))

(defcustom logview-reassurance-chars 5000
  "Compare this many characters before appending file tail.
This value is used by the command `logview-append-log-file-tail'
to compare part of the file on disk with part of the buffer to
make sure (even if not with 100% guarantee) that the buffer
really represents beginning of its backing file.  The command
will refuse to complete operation unless this check succeeds."
  :group 'logview
  :type  'integer)


(defcustom logview-copy-visible-text-only t
  "Whether to copy, kill, etc. only visible selected text.
Standard Emacs behavior is to copy even invisible text, but that
typically doesn't make much sense with filtering.

To temporarily change this on per-buffer basis type \\<logview-mode-map>\\[logview-toggle-copy-visible-text-only]."
  :group 'logview
  :type  'boolean)

(defcustom logview-search-only-in-messages nil
  "Whether to incrementally search only in messages.
Normally search is not restricted and matches can be found
anywhere.  However, it is sometimes useful to ignore other parts
of log entries, e.g. timestamp when searching for numbers.

To temporarily change this on per-buffer basis type \\<logview-mode-map>\\[logview-toggle-search-only-in-messages]."
  :group 'logview
  :type  'boolean)

(defcustom logview-show-ellipses t
  "Whether to show ellipses to indicate hidden log entries.

To temporarily change this on per-buffer basis type \\<logview-mode-map>\\[logview-toggle-show-ellipses]."
  :group 'logview
  :type  'boolean)


(defgroup logview-faces nil
  "Faces for Logview mode."
  :group 'logview)

(defface logview-level-error
  '((t :inherit error))
  "Face to use for error level strings.")

(defface logview-error-entry
  '((((background dark))
     :background "#600000")
    (t
     :background "#ffe0e0"))
  "Face to use for error log entries."
  :group 'logview-faces)

(defface logview-level-warning
  '((t :inherit warning))
  "Face to use for warning level strings."
  :group 'logview-faces)

(defface logview-warning-entry
  '((((background dark))
     :background "#606000")
    (t
     :background "#ffffe0"))
  "Face to use for warning log entries."
  :group 'logview-faces)

(defface logview-level-information
  '((t :inherit success))
  "Face to use for information level strings."
  :group 'logview-faces)

(defface logview-information-entry
  '((((background dark))
     :background "#004000")
    (t
     :background "#e8ffe8"))
  "Face to use for information log entries."
  :group 'logview-faces)

(defface logview-level-debug
  nil
  "Face to use for debug level strings."
  :group 'logview-faces)

(defface logview-debug-entry
  nil
  "Face to use for debug log entries."
  :group 'logview-faces)

(defface logview-level-trace
  '((t :inherit shadow))
  "Face to use for trace level strings."
  :group 'logview-faces)

(defface logview-trace-entry
  '((((background dark))
     :background "#404040")
    (t
     :background "#f0f0f0"))
  "Face to use for trace log entries."
  :group 'logview-faces)

(defface logview-timestamp
  '((t :inherit font-lock-builtin-face))
  "Face to use for log entry timestamp."
  :group 'logview-faces)

(defface logview-name
  '((t :inherit font-lock-string-face))
  "Face to use for logger name."
  :group 'logview-faces)

(defface logview-thread
  '((t :inherit font-lock-variable-name-face))
  "Face to use for logger thread."
  :group 'logview-faces)

(defface logview-edit-filters-type-prefix
  '((((background dark))
     :background "#604000"
     :weight     bold)
    (t
     :background "#ffe0c0"
     :weight     bold))
  "Face to use for type prefixes in filter editing buffer."
  :group 'logview-faces)



;;; Internal variables and constants.

(defconst logview--timestamp-group 1)
(defconst logview--level-group     2)
(defconst logview--name-group      3)
(defconst logview--thread-group    4)

(defconst logview--final-levels '(error warning information debug trace))

(defconst logview--entry-parts '("TIMESTAMP" "LEVEL" "NAME" "THREAD"))
(defconst logview--entry-part-regexp (rx (or (group bow "TIMESTAMP" eow)
                                             (group bow "LEVEL" eow)
                                             (group bow "NAME" eow)
                                             (group bow "THREAD" eow))))

(defconst logview--valid-filter-prefixes '("a+" "a-" "t+" "t-" "m+" "m-"))


(defvar-local logview--entry-regexp nil)
(defvar-local logview--submode-features nil)

(defvar-local logview--submode-level-alist nil
  "Submode levels mapped to final levels.
Levels are ordered least to most important.")

(defvar-local logview--submode-level-data nil
  "An alist of level string to the following lists:
- level symbol (for quick filtering);
- level entry face;
- level string face.")

(defvar-local logview--min-shown-level     nil)
(defvar-local logview--as-important-levels nil)
(defvar-local logview--hide-all-details    nil)

(defvar-local logview--current-filter-text nil)

;; Currently a list of three items: matching function, inclusion and
;; exclusion regexps.
(defvar-local logview--name-filter    nil)
(defvar-local logview--thread-filter  nil)
(defvar-local logview--message-filter nil)

(defvar logview--empty-filter-id '((nil nil) (nil nil) (nil nil)))
(defvar-local logview--applied-filter-id logview--empty-filter-id)

(defvar logview--name-regexp-history)
(defvar logview--thread-regexp-history)
(defvar logview--message-regexp-history)

(defvar-local logview--process-buffer-changes nil)

(defvar-local logview--filter-editing-buffer nil)


(defvar-local logview-filter-edit--parent-buffer nil)
(defvar-local logview-filter-edit--window-configuration nil)

(defvar logview-filter-edit--hint-comment
  "# Press C-c C-c to save edited filters, C-c C-k to quit without saving.
")



;;; Macros and inlined functions.

;; Lisp is sensitive to declaration order, so these are collected at
;; the beginnig of the file.

(defmacro logview--std-matching (&rest body)
  (declare (indent 0) (debug t))
  `(save-excursion
     (let ((case-fold-search nil))
       ,@body)))

(defmacro logview--std-matching-and-altering (&rest body)
  (declare (indent 0) (debug t))
  `(save-excursion
     (let ((logview--process-buffer-changes nil)
           (case-fold-search                nil)
           (inhibit-read-only               t))
       (with-silent-modifications
         ,@body))))


;; The following (inlined) functions are needed when applying
;; 'invisible' property.  Generally we count entry from start of its
;; line to the start of next entry's line.  This works nice e.g. for
;; highlighting.  However, for hiding entries we need to take linefeed
;; that _preceeds_ the entry, otherwise ellipses show at line
;; beginnings, which is ugly and shifts actual buffer text.

(defsubst logview--linefeed-back-checked (position)
  "Return end of previous line.
This function assumes POSITION is at the beginning of a line.  If
this is the first line, don't change POSITION."
  (if (> position 1)
      (1- position)
    1))

(defsubst logview--linefeed-back (position)
  "Return end of previous line assumin non-first line.
This function assumes POSITION is at the beginning of a line and
that the line is not the first in the buffer."
  (1- position))



;;; The mode.

(defvar logview-mode-map
  (let ((map (make-sparse-keymap)))
    (suppress-keymap map)
    (dolist (binding '(;; Movement commands.
                       ("TAB" logview-go-to-message-beginning)
                       ("n"   logview-next-entry)
                       ("p"   logview-previous-entry)
                       ("N"   logview-next-as-important-entry)
                       ("P"   logview-previous-as-important-entry)
                       ("<"   logview-first-entry)
                       (">"   logview-last-entry)
                       ;; Narrowing/widening commands.
                       ("["   logview-narrow-from-this-entry)
                       ("]"   logview-narrow-up-to-this-entry)
                       ("w"   widen)
                       ("{"   logview-widen-upwards)
                       ("}"   logview-widen-downwards)
                       ;; Filtering by level commands.
                       ("l 1" logview-show-only-errors)
                       ("l e" logview-show-only-errors)
                       ("l 2" logview-show-errors-and-warnings)
                       ("l w" logview-show-errors-and-warnings)
                       ("l 3" logview-show-errors-warnings-and-information)
                       ("l i" logview-show-errors-warnings-and-information)
                       ("l 4" logview-show-errors-warnings-information-and-debug)
                       ("l d" logview-show-errors-warnings-information-and-debug)
                       ("l 5" logview-show-all-levels)
                       ("l t" logview-show-all-levels)
                       ("+"   logview-show-only-as-important)
                       ("l +" logview-show-only-as-important)
                       ;; Filtering by name/thread/message commands.
                       ("f"   logview-edit-filters)
                       ("a"   logview-add-include-name-filter)
                       ("A"   logview-add-exclude-name-filter)
                       ("t"   logview-add-include-thread-filter)
                       ("T"   logview-add-exclude-thread-filter)
                       ("m"   logview-add-include-message-filter)
                       ("M"   logview-add-exclude-message-filter)
                       ;; Filter resetting commands.
                       ("r l" logview-reset-level-filters)
                       ("r a" logview-reset-name-filters)
                       ("r t" logview-reset-thread-filters)
                       ("r m" logview-reset-message-filters)
                       ("R"   logview-reset-all-filters)
                       ("r e" logview-reset-all-filters-restrictions-and-hidings)
                       ;; Explicit entry hiding/showing commands.
                       ("h"   logview-hide-entry)
                       ("H"   logview-hide-region-entries)
                       ("s"   logview-show-entries)
                       ("S"   logview-show-region-entries)
                       ;; Showing/hiding entry details commands.
                       ("d"   logview-toggle-entry-details)
                       ("D"   logview-toggle-region-entry-details)
                       ("e"   logview-toggle-details-globally)
                       ;; Option changing commands.
                       ("o r" auto-revert-mode)
                       ("o t" auto-revert-tail-mode)
                       ("o v" logview-toggle-copy-visible-text-only)
                       ("o m" logview-toggle-search-only-in-messages)
                       ("o e" logview-toggle-show-ellipses)
                       ("o S" logview-customize-submode-options)
                       ;; For compatibility with the inactive keymap.
                       ("C-c C-s" logview-customize-submode-options)
                       ;; Miscellaneous commands.
                       ("?"   logview-mode-help)
                       ("x"   logview-append-log-file-tail)
                       ("X"   logview-revert-buffer)
                       ("q"   bury-buffer)
                       ;; Simplified universal argument command
                       ;; rebindings.  Digits and minus are set up by
                       ;; 'suppress-keymap' already.
                       ("u"   universal-argument)))
      (define-key map (kbd (car binding)) (cadr binding)))
    map))

(defvar logview-mode-inactive-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-c C-s") 'logview-customize-submode-options)
    map)
  "Keymap used by `logview-mode' when the mode is inactive.
Mode is inactive when the buffer is not read-only (to not
interfere with editing) or if submode wasn't guessed
successfully.")


;;;###autoload
(define-derived-mode logview-mode nil "Logview"
  "Major mode for viewing and filtering various log files."
  (logview--update-invisibility-spec)
  (logview--update-keymap)
  (add-hook 'read-only-mode-hook 'logview--update-keymap nil t)
  (set (make-local-variable 'filter-buffer-substring-function) 'logview--buffer-substring-filter)
  (set (make-local-variable 'isearch-filter-predicate)         'logview--isearch-filter-predicate)
  (add-hook 'change-major-mode-hook 'logview--exiting-mode nil t)
  (logview--guess-submode)
  (unless (logview-initialized-p)
    (message "Cannot determine log format; press C-c C-s to customize relevant options")))

(defun logview--update-keymap ()
  (use-local-map (if (and buffer-read-only (logview-initialized-p))
                     logview-mode-map
                   logview-mode-inactive-map)))

(defun logview--exiting-mode ()
  ;; Remove custom invisibility property values, as otherwise other
  ;; modes will show empty buffers.  Also remove face property, as we
  ;; set it ourselves, not through font-lock.
  (logview--std-matching-and-altering
    (remove-text-properties 1 (1+ (buffer-size)) '(face nil invisible nil))))

(defun logview-initialized-p ()
  (not (null logview--entry-regexp)))



;;; Movement commands.

(defun logview-go-to-message-beginning (&optional select-message)
  "Put point at the beginning of the current entry's message.

With prefix argument, additionally put mark at the end of the
message, which is especially useful for multiline messages.  In
Transient Mark mode also activate the region."
  (interactive "P")
  (logview--assert)
  (let ((case-fold-search nil))
    (when (logview--match-current-entry)
      (goto-char (match-end 0))
      (when select-message
        (save-excursion
          (push-mark (logview--linefeed-back (if (equal (logview--match-successive-entries 1) 0)
                                                 (match-beginning 0)
                                               (point-max)))
                     t t))))))

(defun logview-next-entry (&optional n)
  "Move point vertically down N (1 by default) log entries.

Point is positioned at the beginning of the message of the
resulting entry.  If log entries are single-line, this is almost
equal to `next-line'.  However, if messages span several lines,
the function will have significantly different effect."
  (interactive "p")
  (logview--assert)
  (when (/= n 0)
    (let ((case-fold-search nil)
          (original-point   (point))
          (remaining        (logview--match-successive-entries n t)))
      (goto-char (if remaining (match-end 0) original-point))
      (logview--maybe-complain-about-movement n remaining))))

(defun logview-previous-entry (&optional n)
  "Move point vertically up N (1 by default) log entries.

Point is positioned at the beginning of the message of the
resulting entry.  If log entries are single-line, this is almost
equal to `next-line'.  However, if messages span several lines,
the function will have significantly different effect."
  (interactive "p")
  (logview-next-entry (if n (- n) -1)))

(defun logview-next-as-important-entry (&optional n)
  "Move point vertically down N 'as important' entries.

Here 'as important' means any entry of level equal or higher than
that of the current entry.  For example, if you start moving from
a warning, the function will stop on all warnings and errors in
the buffer, but skip all other 'less important' entries.  If the
last used command is either `logview-next-as-important-entry' or
`logview-previous-as-important-entry', list of what is considered
'as important' is kept, otherwise it is recomputed anew.

Point is positioned at the beginning of the message of the
resulting entry."
  (interactive "p")
  (logview--assert 'level)
  (when (/= n 0)
    (let ((case-fold-search nil)
          (original-point   (point)))
      (unless (memq last-command '(logview-next-as-important-entry logview-previous-as-important-entry))
        (setq logview--as-important-levels nil)
        (logview--match-current-entry)
        (let ((this-level (match-string logview--level-group))
              (found))
          (dolist (level-pair logview--submode-level-alist)
            (unless found
              (setq found (equal (car level-pair) this-level)))
            (when found
              (push (car level-pair) logview--as-important-levels)))))
      (let ((remaining (logview--match-successive-entries
                        n t (lambda ()
                              (member (match-string logview--level-group) logview--as-important-levels)))))
        (goto-char (if remaining (match-end 0) original-point))
        (logview--maybe-complain-about-movement n remaining t)))))

(defun logview-previous-as-important-entry (&optional n)
  "Move point vertically up N 'as important' entries.

See function `logview-next-as-important-entry' for definition of
'as important'.

Point is positioned at the beginning of the message of the
resulting entry."
  (interactive "p")
  (logview-next-as-important-entry (if n (- n) -1)))

(defun logview-first-entry ()
  "Move point to the first log entry.

Point is positioned at the beginning of the message of the entry.
Otherwise this function is similar to `beginning-of-buffer'."
  (interactive)
  (logview--assert)
  (unless (region-active-p)
    (push-mark))
  (goto-char (point-min))
  (let ((case-fold-search nil))
    (when (logview--match-current-entry)
      (goto-char (match-end 0)))))

(defun logview-last-entry ()
  "Move point to the last log entry.

Point is positioned at the beginning of the message of the entry.
If the last entry is multiline, this makes the function quite
different from `end-of-buffer'."
  (interactive)
  (logview--assert)
  (unless (region-active-p)
    (push-mark))
  (goto-char (point-max))
  (let ((case-fold-search nil))
    (when (logview--match-current-entry)
      (goto-char (match-end 0)))))



;;; Narrowing/widening commands.

(defun logview-narrow-from-this-entry (&optional n)
  "Narrow the buffer so that previous log entries are hidden.

If invoked interactively with a prefix argument, leave that many
entries above the current visible after narrowing.  Note that as
an exception to standard numeric prefix value rules, here no
prefix means zero."
  (interactive (list (when current-prefix-arg
                       (prefix-numeric-value current-prefix-arg))))
  (logview--do-narrow-one-side t n))

(defun logview-narrow-up-to-this-entry (&optional n)
  "Narrow the buffer so that following log entries are hidden.

If invoked interactively with a prefix argument, leave that many
entries under the current visible after narrowing.  Note that as
an exception to standard numeric prefix value rules, here no
prefix means zero."
  (interactive (list (when current-prefix-arg
                       (prefix-numeric-value current-prefix-arg))))
  (logview--do-narrow-one-side nil n))

(defun logview--do-narrow-one-side (upwards n)
  (logview--assert)
  (let ((from (point-min))
        (to   (point-max)))
    (widen)
    (logview--std-matching
      (narrow-to-region (if (and upwards (equal (logview--match-successive-entries (if n (- n) 0) t) 0))
                            (match-beginning 0)
                          from)
                        (if (and (not upwards) (equal (logview--match-successive-entries (if n (1+ n) 1) t) 0))
                            (match-beginning 0)
                          to)))))

(defun logview-widen-upwards ()
  "Widen the buffer only upwards, i.e. keep the bottom restriction."
  (interactive)
  (let ((to (point-max)))
    (widen)
    (narrow-to-region (point-min) to)))

(defun logview-widen-downwards ()
  "Widen the buffer only downwards, i.e. keep the top restriction."
  (interactive)
  (let ((from (point-min)))
    (widen)
    (narrow-to-region from (point-max))))



;;; Filtering by level commands.

(defun logview-show-only-errors ()
  "Show only error entries."
  (interactive)
  (logview--set-min-level (logview--find-min-level 'error)))

(defun logview-show-errors-and-warnings ()
  "Show only error and warning entries."
  (interactive)
  (logview--set-min-level (logview--find-min-level 'warning)))

(defun logview-show-errors-warnings-and-information ()
  "Show error, warning and information entries."
  (interactive)
  (logview--set-min-level (logview--find-min-level 'information)))

(defun logview-show-errors-warnings-information-and-debug ()
  "Show error, warning, information and debug entries.
I.e. all entries other than traces."
  (interactive)
  (logview--set-min-level (logview--find-min-level 'debug)))

(defun logview-show-all-levels ()
  "Show entries of all levels.
This doesn't cancel other filters that might be in effect
though."
  (interactive)
  (logview--set-min-level (logview--find-min-level 'trace)))

(defun logview-show-only-as-important ()
  "Show entries 'as important' as the current.

Here 'as important' means any entry of level equal or higher.
For example, if you invoke this function while current entry is a
warning, all entries other than warnings and errors will be
hidden."
  (interactive)
  (logview--assert 'level)
  (logview--std-matching
    (when (logview--match-current-entry)
      (logview--set-min-level (match-string logview--level-group)))))

(defun logview--find-min-level (final-level)
  "Find minimal submode level that maps to given FINAL-LEVEL or higher."
  (logview--assert 'level)
  (let ((result)
        (final-level-index (cl-position final-level logview--final-levels)))
    (dolist (level-pair logview--submode-level-alist)
      (when (and (null result) (<= (cl-position (cdr level-pair) logview--final-levels :test 'equal) final-level-index))
        (setq result (car level-pair))))
    result))

(defun logview--set-min-level (min-level)
  (setq logview--min-shown-level min-level)
  (logview--update-invisibility-spec))



;;; Filtering by name/thread commands.

(defun logview-edit-filters ()
  (interactive)
  (let ((self    (current-buffer))
        (windows (current-window-configuration))
        (filters logview--current-filter-text))
    (unless (buffer-live-p logview--filter-editing-buffer)
      (setq logview--filter-editing-buffer (generate-new-buffer (format "%s: Filters" (buffer-name)))))
    (split-window-vertically)
    (other-window 1)
    (switch-to-buffer logview--filter-editing-buffer)
    (unless (eq major-mode 'logview-filter-edit-mode)
      (logview-filter-edit-mode))
    (setq logview-filter-edit--parent-buffer        self
          logview-filter-edit--window-configuration windows)
    (logview-filter-edit--initialize-text filters)))

(defun logview-add-include-name-filter ()
  "Show only entries with name matching regular expression.
If this command is invoked multiple times, show entries with name
matching at least one of entered expression."
  (interactive)
  (logview--prompt-for-new-filter "Logger name regexp to show entries" 'name "a+"))

(defun logview-add-exclude-name-filter ()
  "Hide entries with name matching entered regular expression.
If this command is invoked multiple times, filter out them all,
i.e. show only entries with name that doesn't match any of
entered expression."
  (interactive)
  (logview--prompt-for-new-filter "Logger name regexp to hide entries" 'name "a-"))

(defun logview-add-include-thread-filter ()
  "Show only entries with thread matching regular expression.
If this command is invoked multiple times, show entries with
thread name matching at least one of entered expression."
  (interactive)
  (logview--prompt-for-new-filter "Thread regexp to show entries" 'thread "t+"))

(defun logview-add-exclude-thread-filter ()
  "Hide entries with thread matching entered regular expression.
If this command is invoked multiple times, filter out them all,
i.e. show only entries with thread name that doesn't match any of
entered expression."
  (interactive)
  (logview--prompt-for-new-filter "Thread regexp to hide entries" 'thread "t-"))

(defun logview-add-include-message-filter ()
  "Show only entries with message matching regular expression.
Expression may be multiline.  If this command is invoked multiple
times, show entries with message matching at least one of entered
expression."
  (interactive)
  (logview--prompt-for-new-filter "Message regexp to show entries" 'message "m+"))

(defun logview-add-exclude-message-filter ()
  "Hide entries with message matching entered regular expression.
Expression may be multiline.  If this command is invoked multiple
times, filter out them all, i.e. show only entries with message
that doesn't match any of entered expression."
  (interactive)
  (logview--prompt-for-new-filter "Message regexp to hide entries" 'message "m-"))

(defun logview--prompt-for-new-filter (prompt type filter-line-prefix)
  (logview--assert type)
  (let* ((default-value (unless (eq type 'message)
                          (logview--std-matching
                            (when (logview--match-current-entry)
                              (let ((base (regexp-quote (match-string (cdr (assq type (list (cons 'name   logview--name-group)
                                                                                            (cons 'thread logview--thread-group))))))))
                                (list base (format "^%s$" base)))))))
         (regexp        (read-regexp prompt default-value (cdr (assq type '((name    . logview--name-regexp-history)
                                                                            (thread  . logview--thread-regexp-history)
                                                                            (message . logview--message-regexp-history)))))))
    (unless (logview--valid-regexp-p regexp)
      (user-error "Invalid regular expression"))
    (when (and (memq type '(name thread)) (string-match "\n" regexp))
      (user-error "Regular expression must not span several lines"))
    (setq logview--current-filter-text (concat logview--current-filter-text
                                               (when (and logview--current-filter-text
                                                          (not (string-suffix-p "\n" logview--current-filter-text)))
                                                 "\n")
                                               filter-line-prefix " " (replace-regexp-in-string "\n" "\n.. " regexp) "\n"))
    (logview--parse-filters)
    (logview--apply-parsed-filters)))

;; This must have been a standard function.
(defun logview--valid-regexp-p (regexp)
  (ignore-errors
    (string-match regexp "")
    t))



;;; Filters resetting commands.

(defun logview-reset-level-filters ()
  "Reset all level filters.

This is actually the same as `logview-show-all-levels'."
  (interactive)
  (logview--assert 'level)
  (logview-show-all-levels))

(defun logview-reset-name-filters ()
  "Reset all name filters."
  (interactive)
  (logview--assert 'name)
  (logview--parse-filters '("a+" "a-"))
  (logview--apply-parsed-filters))

(defun logview-reset-thread-filters ()
  "Reset all thread filters."
  (interactive)
  (logview--assert 'thread)
  (logview--parse-filters '("t+" "t-"))
  (logview--apply-parsed-filters))

(defun logview-reset-message-filters ()
  "Reset all message filters."
  (interactive)
  (logview--assert)
  (logview--parse-filters '("m+" "m-"))
  (logview--apply-parsed-filters))

(defun logview-reset-all-filters ()
  "Reset all filters (level, name, thread).
After this command only explictly hidden entries and entries
outside narrowing buffer restrictions remain invisible."
  (interactive)
  (logview--do-reset-all-filters nil nil))

(defun logview-reset-all-filters-restrictions-and-hidings ()
  "Reset all visibility restrictions.
In other words, reset all filters, show all explictly hidden
entries and cancel any narrowing restrictions."
  (interactive)
  (widen)
  (logview--do-reset-all-filters t t))

(defun logview--do-reset-all-filters (also-show-details also-cancel-explicit-hiding)
  (logview--assert)
  (when also-show-details
    (setq logview--hide-all-details nil))
  (if (memq 'level logview--submode-features)
      (logview-reset-level-filters)
    (when also-show-details
      (logview--update-invisibility-spec)))
  (when (or (memq 'name logview--submode-features) (memq 'thread logview--submode-features) also-cancel-explicit-hiding)
    (logview--parse-filters logview--valid-filter-prefixes)
    (logview--apply-parsed-filters also-cancel-explicit-hiding)))



;;; Explicit entry hiding/showing commands.

(defun logview-hide-entry (&optional n)
  "Explicitly hide N currently visible entries starting at point.
If N is negative, hide -N previous entries instead, not including
the current.

In Transient Mark mode, if the region is active and this command
is invoked without prefix argument, hide all entries in the
region instead (i.e. just like `logview-hide-region-entries')."
  (interactive (list (if (or current-prefix-arg (not (use-region-p)))
                         (prefix-numeric-value current-prefix-arg)
                       'use-region)))
  (if (eq n 'use-region)
      (logview-hide-region-entries (point) (mark))
    (logview--assert)
    (logview--std-matching-and-altering
      (logview--maybe-complain-about-movement
       n (logview--iterate-successive-entries n (logview--hide-entry-callback 'logview-hidden-entry) t) 0))))

(defun logview-hide-region-entries (begin end)
  "Explicitly hide all log entries in the region.
Entries that are in the region only partially are hidden as well.

Note that this includes entries that are currently hidden due to
filtering too.  If you later cancel filtering, all entries in the
region will remain hidden until you also cancel the explicit
hiding."
  (interactive "r")
  (logview--assert)
  (logview--std-matching-and-altering
    (logview--iterate-entries-in-region begin end (logview--hide-entry-callback 'logview-hidden-entry))))

(defun logview-show-entries (&optional n)
  "Show explicitly hidden entries.
By default, explicitly hidden entries between the current and the
next visible are shown.  If invoked with prefix argument, entries
between the current entry and N'th after it (or before it if N is
negative) are shown.

In Transient Mark mode, if the region is active and this command
is invoked without prefix argument, show explicitly hidden
entries in the region instead (i.e. work just like
`logview-show-region-entries')."
  (interactive (list (if (or current-prefix-arg (not (use-region-p)))
                         (prefix-numeric-value current-prefix-arg)
                       'use-region)))
  (if (eq n 'use-region)
      (logview-show-region-entries (point) (mark))
    (logview--assert)
    ;; Much like 'logview--iterate-successive-entries', but because of
    ;; peculiar semantics, not broken out into its own function.
    (when (/= n 0)
      (logview--std-matching-and-altering
        (let ((direction (cl-signum n))
              (shower    (logview--show-entry-callback 'logview-hidden-entry)))
          (funcall (if (< n 0)
                       'logview--iterate-entries-backward
                     ;; To "not count" the current entry.
                     (setq n (1+ n))
                     'logview--iterate-entries-forward)
                   (lambda (begin after-first-line entry-end)
                     (if (invisible-p begin)
                         (progn
                           (funcall shower begin after-first-line entry-end)
                           t)
                       (/= (setq n (- n direction)) 0)))))))
    (logview--maybe-complain-about-movement n n)))

(defun logview-show-region-entries (begin end)
  "Explicitly show all log entries in the region.

Note that entries that are currently hidden due to filtering are
also marked as 'not explicitly hidden'.  However, you will see
any effect only once you clear or alter the responsible filters."
  (interactive "r")
  (logview--assert)
  (logview--std-matching-and-altering
    (logview--iterate-entries-in-region begin end (logview--show-entry-callback 'logview-hidden-entry))))



;;; Showing/hiding entry details commands.

(defun logview-toggle-entry-details (&optional arg)
  "Toggle whether details for current entry are shown.
If invoked with prefix argument, show them if the argument is
positive, hide otherwise.

In Transient Mark mode, if the region is active, call
`logview-toggle-region-entry-details'.  See that function help
for how toggling works."
  (interactive (list (if (use-region-p)
                         (list (or current-prefix-arg 'toggle))
                       (or current-prefix-arg 'toggle))))
  (if (consp arg)
      (logview-toggle-region-entry-details (point) (mark) (car arg))
    (save-excursion
      (save-restriction
        (widen)
        (logview--std-matching-and-altering
          (when (logview--match-current-entry)
            (forward-line)
            (let ((after-first-line (point))
                  (end              (if (logview--match-successive-entries 1)
                                        (match-beginning 0)
                                      (point-max))))
              (if (<= end after-first-line)
                  (user-error "Current entry has no details")
                (logview--change-entry-details-visibility after-first-line end
                                                          (if (eq arg 'toggle)
                                                              (memq 'logview-hidden-details
                                                                    (get-text-property (logview--linefeed-back after-first-line) 'invisible))
                                                            (> (prefix-numeric-value arg) 0)))))))))))

(defun logview-toggle-region-entry-details (begin end &optional arg)
  "Toggle whether details in the region are shown.
Toggling works like this: if at least one entry in the region has
details that are visible, all are hidden.  Otherwise, if all are
already hidden, they are shown.  If invoked with prefix argument,
show details if the argument is positive, hide otherwise.

Entries that are in the region only partially are operated on as
well."
  (interactive (list (point) (mark) (or current-prefix-arg 'toggle)))
  (save-excursion
    (save-restriction
      (widen)
      (logview--std-matching-and-altering
        (when (eq arg 'toggle)
          (setq arg 1)
          (logview--iterate-entries-in-region begin end (lambda (_begin after-first-line end)
                                                          (if (or (>= after-first-line end)
                                                                  (memq 'logview-hidden-details (get-text-property after-first-line 'invisible)))
                                                              t
                                                            (setq arg 0)
                                                            nil))))
        (let ((show (> (prefix-numeric-value arg) 0)))
          (logview--iterate-entries-in-region begin end (lambda (_begin after-first-line end)
                                                          (logview--change-entry-details-visibility after-first-line end show)
                                                          t)))))))

(defun logview--change-entry-details-visibility (after-first-line end show)
  (let* ((current-invisible (get-text-property (logview--linefeed-back after-first-line) 'invisible))
         (new-invisible     current-invisible))
    (if show
        (setq new-invisible (remq 'logview-hidden-details new-invisible))
      (unless (memq 'logview-hidden-details new-invisible)
        (push 'logview-hidden-details new-invisible)))
    (unless (eq new-invisible current-invisible)
      (put-text-property (logview--linefeed-back after-first-line) (logview--linefeed-back end) 'invisible new-invisible))))


(defun logview-toggle-details-globally (&optional arg)
  (interactive (list (or current-prefix-arg 'toggle)))
  (logview--toggle-option-locally 'logview--hide-all-details arg (called-interactively-p 'interactive)
                                  "All entry messages details are now hidden"
                                  "Details of entry messages are now visible unless hidden explicitly")
  (logview--update-invisibility-spec))



;;; Option changing commands.

(defun logview-toggle-copy-visible-text-only (&optional arg)
  "Toggle `logview-copy-visible-text-only' just for this buffer.

If invoked with prefix argument, enable the option if the
argument is positive, disable it otherwise."
  (interactive (list (or current-prefix-arg 'toggle)))
  (logview--toggle-option-locally 'logview-copy-visible-text-only arg (called-interactively-p 'interactive)
                                  "Will copy only visible text now"
                                  "Copying commands will behave as in the rest of Emacs"))

(defun logview-toggle-search-only-in-messages (&optional arg)
  "Toggle `logview-search-only-in-messages' just for this buffer.

If invoked with prefix argument, enable the option if the
argument is positive, disable it otherwise."
  (interactive (list (or current-prefix-arg 'toggle)))
  (logview--toggle-option-locally 'logview-search-only-in-messages arg (called-interactively-p 'interactive)
                                  "Incremental search will find matches only in messages"
                                  "Incremental search will behave normally"))

(defun logview-toggle-show-ellipses (&optional arg)
  "Toggle `logview-show-ellipses' just for this buffer.

If invoked with prefix argument, enable the option if the
argument is positive, disable it otherwise."
  (interactive (list (or current-prefix-arg 'toggle)))
  (logview--toggle-option-locally 'logview-show-ellipses arg (called-interactively-p 'interactive)
                                  "Showing ellipses to indicate hidden log entries"
                                  "Hidden log entries are completely invisible")
  (logview--update-invisibility-spec))

(defun logview-customize-submode-options ()
  "Customize all options that affect submode selection.
These are:
* `logview-additional-submodes'
* `logview-additional-level-mappings'
* `logview-additional-timestamp-formats'"
  (interactive)
  ;; Existing entry point only customizes single option, we need three
  ;; at once (but this hardly warrants a separate group).
  (custom-buffer-create-other-window '((logview-additional-submodes          custom-variable)
                                       (logview-additional-level-mappings    custom-variable)
                                       (logview-additional-timestamp-formats custom-variable))
                                     "*Customize Logview Submodes*"))

(defun logview--toggle-option-locally (variable arg &optional show-message message-if-true message-if-false)
  (set (make-local-variable variable)
       (if (eq arg 'toggle)
           (not (symbol-value variable))
         (> (prefix-numeric-value arg) 0)))
  (when show-message
    (message (if (symbol-value variable) message-if-true message-if-false))))



;;; Miscellaneous commands.

(defun logview-mode-help ()
  (interactive)
  ;; FIXME: Write
  )

(defun logview-append-log-file-tail ()
  "Load log file tail into the buffer preserving active filters.
This command won't ask for confirmation, but cannot be used if
the buffer is modified.

Before loading the tail it verifies that preceding contents
matches that of the buffer.  The command does that by comparing
`logview-reassurance-chars' immediately before the tail with the
end of the buffer. This is of course not fool-proof, but for log
files almost always good enough, especially if they contain
timestamps.

This can be seen as an alternative to `auto-revert-tail-mode':
instead of automatic reverting you ask for it explicitly.  It
should be as simple as typing \\<logview-mode-map>\\[logview-append-log-file-tail], as no confirmations are asked."
  (interactive)
  (when (buffer-modified-p)
    (user-error "Cannot append file tail to a modified buffer"))
  (let* ((buffer             (current-buffer))
         (file               buffer-file-name)
         (size               (1+ (buffer-size)))
         (reassurance-chars  (min (max logview-reassurance-chars 0) (1- size)))
         (compare-from       (- size reassurance-chars))
         ;; 'position-bytes' appears to count from 1, yet we need
         ;; zero-based offset.
         (compare-from-bytes (1- (position-bytes compare-from))))
    (with-temp-buffer
      (insert-file-contents file nil compare-from-bytes nil)
      (let ((temporary      (current-buffer))
            (temporary-size (buffer-size)))
        (unless (and (>= temporary-size reassurance-chars)
                     (string= (buffer-substring-no-properties 1 (1+ reassurance-chars))
                              (with-current-buffer buffer
                                (save-restriction
                                  (widen)
                                  (buffer-substring-no-properties compare-from size)))))
          (user-error "Buffer contents doesn't match the head of %s anymore" file))
        (if (= temporary-size reassurance-chars)
            (message "Backing file %s hasn't grown" file)
          (with-current-buffer buffer
            (let ((was-modified      (buffer-modified-p))
                  (inhibit-read-only t)
                  ;; This is to avoid unnecessary confirmation about
                  ;; modifying a buffer with externally changed file.
                  (buffer-file-name  nil))
              (save-restriction
                (widen)
                (save-excursion
                  (goto-char (point-max))
                  (insert-buffer-substring-no-properties temporary (1+ reassurance-chars) (1+ temporary-size))))
              (restore-buffer-modified-p was-modified))
            (message "Appended the tail of file %s" file)))))))

(defun logview-revert-buffer ()
  "Revert the buffer preserving active filters.
This command won't ask for confirmation unless the buffer is
modified.

This can be seen as an alternative to `auto-revert-mode': instead
of automatic reverting you ask for it explicitly.  It should be
as simple as typing \\<logview-mode-map>\\[logview-revert-buffer], as no confirmations are asked."
  (interactive)
  (let ((revert-without-query (when buffer-file-name (list (regexp-quote buffer-file-name))))
        (was-read-only        buffer-read-only))
    (revert-buffer nil nil t)
    ;; Apparently 'revert-buffer' resets this.
    (read-only-mode (if was-read-only 1 0)))
  ;; If reverting fails we just won't even get here.
  (message "Reverted the buffer"))



;;; Internal functions (except helpers for specific command groups).

(defun logview--guess-submode ()
  (save-excursion
    (save-restriction
      (widen)
      (goto-char 1)
      (end-of-line)
      (let ((first-line (buffer-substring 1 (point))))
        (catch 'success
          (logview--iterate-split-alists (lambda (name definition)
                                           (condition-case error
                                               (logview--initialize-submode name definition first-line)
                                             (error (warn (error-message-string error)))))
                                         logview-additional-submodes logview-std-submodes))))))

(defun logview--initialize-submode (name definition test-line)
  (let* ((format    (cdr (assq 'format    definition)))
         (timestamp (cdr (assq 'timestamp definition))))
    (unless (and (stringp format) (> (length format) 0))
      (user-error "Invalid submode '%s': no format string" name))
    (catch 'failed
      (if timestamp
          (dolist (name timestamp)
            (logview--try-initialize-submode name definition format
                                             (logview--get-split-alists name "timestamp format"
                                                                        logview-additional-timestamp-formats logview-std-timestamp-formats)
                                             test-line))
        (logview--iterate-split-alists (lambda (_timestamp-name timestamp)
                                         (logview--try-initialize-submode name definition format timestamp test-line))
                                       logview-additional-timestamp-formats logview-std-timestamp-formats)))))

(defun logview--try-initialize-submode (name submode format timestamp test-line)
  (let* ((search-from 0)
         (next)
         (end)
         starter terminator
         (levels)
         (parts '("^"))
         (features)
         (add-text-part (lambda (from to)
                          (push (replace-regexp-in-string "[ \t]+" "[ \t]+" (regexp-quote (substring format from to))) parts))))
    (while (setq next (string-match logview--entry-part-regexp format search-from))
      (when (> next search-from)
        (funcall add-text-part search-from next))
      (setq end        (match-end 0)
            starter    (when (> next 0)
                         (aref format (1- next)))
            terminator (when (< end (length format))
                         (aref format end)))
      (cond ((match-beginning logview--timestamp-group)
             (push (format "\\(?%d:%s\\)" logview--timestamp-group (cdr (assq 'regexp timestamp))) parts)
             (push 'timestamp features))
            ((match-beginning logview--level-group)
             (setq levels (logview--get-split-alists (cdr (assq 'levels submode)) "level mapping"
                                                     logview-additional-level-mappings logview-std-level-mappings))
             (push (format "\\(?%d:%s\\)" logview--level-group
                           (regexp-opt (apply 'append (mapcar (lambda (final-level) (cdr (assq final-level levels)))
                                                              logview--final-levels))))
                   parts)
             (push 'level features))
            (t
             (dolist (k (list logview--name-group logview--thread-group))
               (when (match-beginning k)
                 (push (format "\\(?%d:%s\\)" k
                               (cond ((and starter terminator
                                           (or (and (= starter ?\() (= terminator ?\)))
                                               (and (= starter ?\[) (= terminator ?\]))))
                                      ;; See https://github.com/doublep/logview/issues/2
                                      ;; We allow _one_ level of nested parens inside
                                      ;; parenthesized THREAD or NAME.  Allowing more would
                                      ;; complicate regexp even further.  Unlimited nesting
                                      ;; level is not possible will regexps at all.
                                      ;;
                                      ;; 'rx-to-string' is used to avoid escaping things
                                      ;; ourselves.
                                      (rx-to-string `(seq (* (not (any ,starter ,terminator ?\n)))
                                                          (* ,starter (* (not (any ?\n))) ,terminator
                                                             (* (not (any ,starter ,terminator ?\n)))))
                                                    t))
                                     ((and terminator (/= terminator ? ))
                                      (format "[^%c\n]*" terminator))
                                     (terminator
                                      "[^ \t\n]+")
                                     (t
                                      ".+")))
                       parts)
                 (push (if (= k logview--name-group) 'name 'thread) features)))))
      (setq search-from end))
    (when (< search-from (length format))
      (funcall add-text-part search-from nil))
    ;; Always behave as if format string ends with whitespace.
    (unless (string-match "[ \t]$" format)
      (push "[ \t]+" parts))
    (let ((regexp (apply 'concat (reverse parts))))
      (if (string-match regexp test-line)
          (progn
            (setq logview--process-buffer-changes t
                  logview--entry-regexp           regexp
                  logview--submode-features       features
                  logview--submode-level-alist    nil
                  mode-name                       (format "Logview/%s" name))
            (when (memq 'level features)
              (dolist (final-level logview--final-levels)
                (dolist (level (cdr (assoc final-level levels)))
                  (setq logview--submode-level-alist (cons (cons level final-level) logview--submode-level-alist))
                  (push (cons level (list (make-symbol level)
                                          (intern (format "logview-%s-entry" (symbol-name final-level)))
                                          (intern (format "logview-level-%s" (symbol-name final-level)))))
                        logview--submode-level-data))))
            (logview--split-region-into-entries (point-min) (point-max) 'report-progress)
            (add-hook 'after-change-functions 'logview--split-region-into-entries t t)
            (read-only-mode 1)
            (when buffer-file-name
              (pcase logview-auto-revert-mode
                (`auto-revert-mode      (auto-revert-mode      1))
                (`auto-revert-tail-mode (auto-revert-tail-mode 1))))
            (throw 'success nil))
        (when (not (memq 'timestamp features))
          ;; Else we will maybe retry with different timestamp formats.
          (throw 'failed nil))))))


(defun logview--assert (&rest assertions)
  (unless (logview-initialized-p)
    (user-error "Couldn't determine log format; press C-c C-s to customize relevant options"))
  (dolist (assertion assertions)
    (unless (or (eq assertion 'message) (memq assertion logview--submode-features))
      (user-error (cdr (assq assertion '((level  . "Log lacks entry levels")
                                         (name   . "Log lacks logger names")
                                         (thread . "Log doesn't include thread names"))))))))


(defun logview--maybe-complain-about-movement (direction remaining &optional as-important-entries)
  ;; Using 'equal' since 'remaining' may also be nil.
  (unless (equal remaining 0)
    (user-error (if as-important-entries
                    (if (> direction 0) "No next (visible) as important entry" "No previous (visible) as important entry")
                  (if (> direction 0) "No next (visible) entry" "No previous (visible) entry")))))


(defun logview--match-current-entry ()
  "Match the header of the log entry where the point currently is.

Return value is non-nil on success.  Point is either before or
after the header, i.e. still in the same log entry, but there are
no more guarantees.  Match data is set appropriately for the
header."
  (forward-line 0)
  (or (looking-at logview--entry-regexp)
      (re-search-backward logview--entry-regexp nil t)
      (re-search-forward  logview--entry-regexp nil t)))

(defun logview--match-successive-entries (n &optional only-visible validator)
  "Match N entries after (if N is positive) or before (negative)
the current one.  If N is zero, match just the current entry.

If ONLY-VISIBLE is non-nil, hidden entries are skipped.  If
VALIDATOR is non-nil, entries for which the function returns nil
are skipped too.

Returns the remaining number, i.e. zero if there are enough valid
entries.  If it never found any valid entries, returns nil.
There is no guarantees about point location after the call, but
match data will be set for the last valid matched header."
  (let* ((forward          (> n 0))
         (direction        (cl-signum n))
         (successful-match '(nil)))
    (when (logview--match-current-entry)
      (when (or (null validator) (funcall validator))
        (match-data t successful-match))
      (when (/= n 0)
        (while (and (= (forward-line direction) 0)
                    (if forward
                        (re-search-forward logview--entry-regexp nil t)
                      (or (looking-at logview--entry-regexp)
                          (re-search-backward logview--entry-regexp nil t)))
                    (if (or (and only-visible (invisible-p (match-beginning 0)))
                            (and validator (not (funcall validator))))
                        t
                      (match-data t successful-match)
                      (/= (setq n (- n direction)) 0))))))
    (if (equal successful-match '(nil))
        nil
      (set-match-data successful-match)
      n)))


(defun logview--iterate-entries-forward (callback &optional only-visible validator)
  "Invoke CALLBACK for successive valid log entries forward.
Iteration starts at the current entry and continues forward until
CALLBACK returns nil or end of buffer is reached.

CALLBACK is called with three arguments: beginning of the entry,
end of its first line and its end (the last two are equal unless
the entry spans multiple lines).  CALLBACK may not access match
data and must make sure point and match data are preserved.

If ONLY-VISIBLE is non-nil, hidden entries are skipped.  If
VALIDATOR is non-nil, entries for which the function returns nil
are skipped too.  VALIDATOR is always called with match data set
and point at the beginning of the next line."
  (when (logview--match-current-entry)
    (let ((entry-begin (match-beginning 0))
          (after-first-line)
          (entry-end)
          (limit       (point-max))
          (invalid))
      (while (progn
               (forward-line)
               (setq invalid (or (and only-visible (invisible-p entry-begin))
                                 (and validator    (not (funcall validator)))))
               (setq after-first-line (point)
                     entry-end        (if (re-search-forward logview--entry-regexp nil t)
                                          (match-beginning 0)
                                        limit))
               (when (or invalid (funcall callback entry-begin after-first-line entry-end))
                 (/= (setq entry-begin entry-end) limit)))))))

(defun logview--iterate-entries-backward (callback &optional only-visible validator)
  "Invoke CALLBACK for successive valid log entries backward.
Iteration starts at the previous entry (not the current!) and
continues backward until CALLBACK returns nil or beginning of
buffer is reached.

See `logview--iterate-entries-forward' for details."
  (when (logview--match-current-entry)
    (let ((entry-begin (match-beginning 0))
          (entry-end))
      (while (and (= (forward-line -1) 0)
                  (or (looking-at logview--entry-regexp)
                      (re-search-backward logview--entry-regexp nil t))
                  (progn
                    (setq entry-end   entry-begin
                          entry-begin (match-beginning 0))
                    (forward-line)
                    (or (and only-visible (invisible-p entry-begin))
                        (and validator    (not (funcall validator)))
                        (when (funcall callback entry-begin (point) entry-end)
                          (goto-char entry-begin)))))))))

(defun logview--iterate-successive-entries (n callback &optional only-visible validator)
  (when (/= n 0)
    (let ((direction (cl-signum n)))
      (funcall (if (> n 0) 'logview--iterate-entries-forward 'logview--iterate-entries-backward)
               (lambda (begin after-first-line entry-end)
                 (funcall callback begin after-first-line entry-end)
                 (/= (setq n (- n direction)) 0))
               only-visible validator)))
  n)

(defun logview--iterate-entries-in-region (begin end callback &optional only-visible validator)
  (goto-char (min begin end))
  (let ((limit (max begin end)))
    (logview--iterate-entries-forward (lambda (begin after-first-line end)
                                        (funcall callback begin after-first-line end)
                                        (< end limit))
                                      only-visible validator)))


(defun logview--update-invisibility-spec ()
  (let ((invisibility-spec '(logview-filtered logview-hidden-entry logview-hidden-details))
        (found nil))
    ;; Initially it's nil.
    (when logview--min-shown-level
      (dolist (level-pair logview--submode-level-alist)
        (when (string= (car level-pair) logview--min-shown-level)
          (setq found t))
        (unless found
          (setq invisibility-spec (cons (nth 0 (cdr (assoc (car level-pair) logview--submode-level-data))) invisibility-spec)))))
    (when logview--hide-all-details
      (setq invisibility-spec (cons 'logview-details invisibility-spec)))
    (setq buffer-invisibility-spec
          (if logview-show-ellipses
              (mapcar (lambda (x) (cons x t)) invisibility-spec)
            invisibility-spec))
    ;; This weird looking command was suggested in
    ;; irc.freenode.net#emacs and seems to force buffer redraw.
    ;; Otherwise change to 'buffer-invisibility-spec' doesn't have
    ;; immediate effect here.
    (force-mode-line-update)))


(defun logview--parse-filters (&optional to-reset)
  ;; As we "leave" current buffer, we need to rebind variables
  ;; locally, so their values are properly transferred.
  (let ((filters logview--current-filter-text)
        non-discarded-lines
        include-name-regexps
        exclude-name-regexps
        include-thread-regexps
        exclude-thread-regexps
        include-message-regexps
        exclude-message-regexps)
    (when filters
      (with-temp-buffer
        (insert filters)
        (goto-char 1)
        (logview--iterate-filter-lines
         (lambda (type line-begin begin end)
           (let ((filter-line       (not (member type '("#" "" nil))))
                 (reset-this-filter (member type to-reset)))
             (when reset-this-filter
               (delete-region begin (point)))
             (when (not (and filter-line reset-this-filter))
               (push (buffer-substring-no-properties line-begin (point)) non-discarded-lines))
             (when (and filter-line (not reset-this-filter))
               (let ((regexp (logview--filter-regexp begin end)))
                 (when (logview--valid-regexp-p regexp)
                   (pcase type
                     ("a+" (push regexp include-name-regexps))
                     ("a-" (push regexp exclude-name-regexps))
                     ("t+" (push regexp include-thread-regexps))
                     ("t-" (push regexp exclude-thread-regexps))
                     ("m+" (push regexp include-message-regexps))
                     ("m-" (push regexp exclude-message-regexps))))))
             t))))
      (setq logview--current-filter-text (apply 'concat (nreverse non-discarded-lines))
            logview--name-filter         (logview--build-filter include-name-regexps    exclude-name-regexps)
            logview--thread-filter       (logview--build-filter include-thread-regexps  exclude-thread-regexps)
            logview--message-filter      (logview--build-filter include-message-regexps exclude-message-regexps)))))

(defun logview--iterate-filter-lines (callback)
  "Find successive filter specification in the current buffer.
Buffer must be positioned at the start of a line.  Iteration
continues until CALLBACK returns nil or end of buffer is reached.

CALLBACK is called with four arguments: TYPE, LINE-BEGIN, BEGIN,
and END.  TYPE may be a string: \"a+\", \"a-\", \"t+\", \"t-\", \"m+\" or
\"m-\" for valid filter types, \"#\" for comment line and \"\" for an
empty line, or nil to indicate an erroneous line.  BEGIN and END
determine filter text boundaries (may span several lines for
message filters.  LINE-BEGIN is the beginnig of the line where
the entry starts; in case of filters this is a few charaters
before BEGIN.  Point is positioned at the start of next line,
which is usually one line beyond END."
  (let ((case-fold-search nil)
        line-begin
        begin
        type)
    (while (and (not (eobp))
                (progn
                  (setq line-begin (point)
                        begin      line-begin
                        type       (when (looking-at "\\([atm][-+]\\) \\|\\s-*\\(#\\)\\|\\s-*$")
                                     (if (match-beginning 1)
                                         (progn (setq begin (match-end 0))
                                                (match-string 1))
                                       (or (match-string 2) ""))))
                  (forward-line)
                  (when (member type '("m+" "m-"))
                    (while (looking-at "\\.\\. ")
                      (forward-line)))
                  (funcall callback type line-begin begin (if (bolp) (logview--linefeed-back-checked (point)) (point))))))))

(defun logview--build-filter (include-regexp-list exclude-regexp-list)
  (let ((include-regexp (logview--build-filter-regexp include-regexp-list))
        (exclude-regexp (logview--build-filter-regexp exclude-regexp-list)))
    (list (if include-regexp
              (if exclude-regexp
                  (lambda (string) (and (string-match include-regexp string) (not (string-match exclude-regexp string))))
                (lambda (string) (string-match include-regexp string)))
            (when exclude-regexp
              (lambda (string) (not (string-match exclude-regexp string)))))
          include-regexp
          exclude-regexp)))

(defun logview--filter-regexp (begin end)
  (replace-regexp-in-string "\n\\.\\. " "\n" (buffer-substring-no-properties begin end)))

(defun logview--apply-parsed-filters (&optional cancel-explicit-hiding)
  (logview--process-region-entries 1 (1+ (buffer-size)) nil cancel-explicit-hiding
                                   (lambda (begin end) (make-progress-reporter "Filtering..." begin end))))

(defun logview--process-region-entries (region-begin region-end set-up-entries cancel-explicit-hiding reporter-builder)
  (let* ((name-filter            (car logview--name-filter))
         (thread-filter          (car logview--thread-filter))
         (no-name/thread-filters (and (null name-filter) (null thread-filter)))
         (message-filter         (car logview--message-filter))
         (filter-id              (list (cdr logview--name-filter) (cdr logview--thread-filter) (cdr logview--message-filter)))
         ;; Need a copy, since entry matching is always case-sensitive
         ;; (see 'logview--std-matching-and-altering').
         (case-insensitive       case-fold-search))
    (when (or set-up-entries cancel-explicit-hiding (not (equal logview--applied-filter-id filter-id)))
      (logview--std-matching-and-altering
        (save-restriction
          (widen)
          (goto-char region-begin)
          (let ((anchored (logview--match-current-entry)))
            (when (and set-up-entries (or (not anchored) (> (point) region-begin)))
              ;; Asked to set up entries, but the buffer begins with
              ;; or completely consists of text we don't recognize.
              (put-text-property 1 (if anchored (match-beginning 0) (1+ (buffer-size))) 'face      nil)
              (put-text-property 1 (if anchored (match-beginning 0) (1+ (buffer-size))) 'invisible nil))
            (when anchored
              (let ((reporter           (when reporter-builder (funcall reporter-builder (match-beginning 0) region-end)))
                    (have-timestamp     (memq 'timestamp logview--submode-features))
                    (have-level         (memq 'level     logview--submode-features))
                    (have-name          (memq 'name      logview--submode-features))
                    (have-thread        (memq 'thread    logview--submode-features))
                    (hider              (logview--hide-entry-callback 'logview-filtered))
                    (shower             (logview--show-entry-callback 'logview-filtered))
                    (explicit-shower    (when cancel-explicit-hiding (logview--show-entry-callback 'logview-hidden-entry)))
                    (num-hidden         0)
                    (num-visible        0)
                    (match-data-storage '(nil))
                    message-begin
                    matches-name/thread
                    level-data)
                ;; Because 'callback' doesn't get access to match
                ;; data, while 'validator' doesn't know all entry
                ;; limits, we use both and pass 'matches-name/thread'
                ;; from the validator to the callback.
                (logview--iterate-entries-forward
                 (lambda (begin after-first-line end)
                   (when (and set-up-entries (< after-first-line end) have-level)
                     (when have-level
                       (put-text-property after-first-line end 'face (nth 1 level-data)))
                     (put-text-property (logview--linefeed-back after-first-line) (logview--linefeed-back end)
                                        'invisible (list (nth 0 level-data) 'logview-details)))
                   ;; Remember that 'matches-name/thread' is not the
                   ;; final value, we still need to check if entry's
                   ;; message passes filters.
                   (if (and matches-name/thread
                            (or (null message-filter)
                                ;; Ideally would just match in the
                                ;; buffer itself, but that's probably
                                ;; unsound due to anchors.
                                (prog2
                                    ;; For speed optimization we don't
                                    ;; use 'save-match-data'.
                                    (match-data t match-data-storage)
                                    (let ((case-fold-search case-insensitive))
                                      (funcall message-filter (buffer-substring-no-properties message-begin end)))
                                  (set-match-data match-data-storage))))
                       (unless set-up-entries
                         (funcall shower begin after-first-line end)
                         (setq num-visible (1+ num-visible)))
                     (funcall hider begin after-first-line end)
                     (setq num-hidden (1+ num-hidden)))
                   (when explicit-shower
                     (funcall explicit-shower begin after-first-line end))
                   (when reporter
                     (progress-reporter-update reporter end))
                   ;; Continuing condition.
                   (< end region-end))
                 nil
                 (lambda ()
                   (let ((case-fold-search case-insensitive))
                     (when set-up-entries
                       (when have-level
                         (setq level-data (cdr (assoc (match-string logview--level-group) logview--submode-level-data)))
                         ;; Point is guaranteed to be at the start of the next line.
                         (put-text-property (match-beginning 0) (point) 'face (nth 1 level-data))
                         (put-text-property (logview--linefeed-back-checked (match-beginning 0)) (logview--linefeed-back (point))
                                            'invisible (list (nth 0 level-data)))
                         (add-face-text-property (match-beginning logview--level-group)
                                                 (match-end       logview--level-group)
                                                 (nth 2 level-data)))
                       (when have-timestamp
                         (add-face-text-property (match-beginning logview--timestamp-group)
                                                 (match-end       logview--timestamp-group)
                                                 'logview-timestamp))
                       (when have-name
                         (add-face-text-property (match-beginning logview--name-group)
                                                 (match-end       logview--name-group)
                                                 'logview-name))
                       (when have-thread
                         (add-face-text-property (match-beginning logview--thread-group)
                                                 (match-end       logview--thread-group)
                                                 'logview-thread)))
                     (setq message-begin       (match-end 0)
                           matches-name/thread (or no-name/thread-filters
                                                   ;; Since the filters involve regexp matching themselves,
                                                   ;; we need to store log entry parts before calling any.
                                                   (let ((name   (when name-filter   (match-string-no-properties logview--name-group)))
                                                         (thread (when thread-filter (match-string-no-properties logview--thread-group))))
                                                     (and (or (null name)   (funcall name-filter   name))
                                                          (or (null thread) (funcall thread-filter thread)))))))
                   ;; Operate on all entries.
                   t))
                (if set-up-entries
                    (when reporter
                      (progress-reporter-done reporter))
                  (cond ((= num-hidden 0)
                         (message (if (equal filter-id logview--empty-filter-id) "Filters are reset" "Filtering complete, nothing was hidden")))
                        ((= num-visible 0)
                         (message "Filtering complete, all entries were hidden"))
                        (t
                         (message "Filtering complete, %d %s out of %d (%.1f%%) %s hidden"
                                  num-hidden (if (= num-hidden 1) "entry" "entries") (+ num-hidden num-visible)
                                  (/ (* num-hidden 100.0) (+ num-hidden num-visible)) (if (= num-hidden 1) "was" "were")))))))))
      (setq logview--applied-filter-id filter-id)))))

;; FIXME: Resulting regexp will not be valid if any of the options
;;        uses group backreferences (\N) and maybe some other
;;        constructs.
(defun logview--build-filter-regexp (options)
  (when options
    ;; To prevent refiltering on insignificant changes, we enforce
    ;; canonical option ordering and drop any duplicates.
    (mapconcat 'identity (delete-consecutive-dups (sort options 'string<)) "\\|")))


(defun logview--show-entry-callback (hider)
  (lambda (begin after-first-line end)
    (let ((value (get-text-property begin 'invisible)))
      (when (memq hider value)
        (put-text-property (logview--linefeed-back-checked begin) (logview--linefeed-back after-first-line)
                           'invisible (remq hider value))
        (when (> end after-first-line)
          (put-text-property (logview--linefeed-back after-first-line) (logview--linefeed-back end)
                             'invisible (remq hider (get-text-property after-first-line 'invisible))))))))

(defun logview--hide-entry-callback (hider)
  (lambda (begin after-first-line end)
    (let ((value (get-text-property begin 'invisible)))
      (unless (memq hider value)
        (put-text-property (logview--linefeed-back-checked begin) (logview--linefeed-back after-first-line)
                           'invisible (cons hider value))
        (when (> end after-first-line)
          (put-text-property (logview--linefeed-back after-first-line) (logview--linefeed-back end)
                             'invisible (cons hider (get-text-property after-first-line 'invisible))))))))


(defun logview--iterate-split-alists (callback &rest alists)
  (let ((seen (make-hash-table :test 'equal)))
    (dolist (alist alists)
      (dolist (entry alist)
        (unless (gethash (car entry) seen)
          (funcall callback (car entry) (cdr entry))
          (puthash (car entry) t seen)
          (dolist (alias (cdr (assq 'aliases (cdr entry))))
            (puthash alias t seen)))))))

(defun logview--get-split-alists (key type &rest alists)
  (catch 'found
    (apply 'logview--iterate-split-alists (lambda (name value)
                                            (when (or (equal name key) (member key (cdr (assq 'aliases value))))
                                              (throw 'found value)))
           alists)
    (user-error "Unknown %s '%s'" type key)))



;;; Internal commands meant as hooks.

(defun logview--split-region-into-entries (begin end &optional old-length)
  "Parse log entries in given region.
Optional third argument is to make the function suitable for
`after-change-functions' and is ignored there.  Special value
'report-progress for this argument is treated differently."
  (when logview--process-buffer-changes
    (save-match-data
      (logview--process-region-entries begin end t nil
                                       (when (eq old-length 'report-progress)
                                         (lambda (begin end) (make-progress-reporter "Parsing buffer..." begin end)))))))

(defun logview--buffer-substring-filter (begin end delete)
  "Optionally remove invisible text from the substring."
  (let ((substring (funcall (default-value 'filter-buffer-substring-function) begin end delete)))
    (if logview-copy-visible-text-only
        (let ((chunks)
              (begin 0)
              (end))
          (while begin
            (setq end (next-single-property-change begin 'invisible substring))
            (when (not (invisible-p (get-text-property begin 'invisible substring)))
              (push (substring substring begin end) chunks))
            (setq begin end))
          (apply 'concat (nreverse chunks)))
      substring)))

(defun logview--isearch-filter-predicate (begin end)
  (and (funcall (default-value 'isearch-filter-predicate) begin end)
       (or (not logview-search-only-in-messages)
             (logview--std-matching
               (save-match-data
                 (save-restriction
                   (widen)
                   (goto-char begin)
                   (or (not (logview--match-current-entry))
                       (and (or (>= (match-beginning 0) end)
                                (and (<= (match-end 0) begin)
                                     (or (not (logview--match-successive-entries 1 t))
                                         (>= (match-beginning 0) end))))))))))))



;;; Logview Filter Edit mode.

(defvar logview-filter-edit-mode-map
  (let ((map (make-sparse-keymap)))
    (dolist (binding '(("C-c C-c" logview-filter-edit-save)
                       ("C-c C-k" logview-filter-edit-cancel)))
      (define-key map (kbd (car binding)) (cadr binding)))
    map))

(define-derived-mode logview-filter-edit-mode nil "Logview Filters"
  "Major mode for editing filters of a Logview buffer."
  (logview-filter-edit--font-lock-region (point-min) (point-max))
  (add-hook 'after-change-functions 'logview-filter-edit--font-lock-region t t))

(defun logview-filter-edit-save ()
  (interactive)
  (logview-filter-edit--quit t))

(defun logview-filter-edit-cancel ()
  (interactive)
  (logview-filter-edit--quit nil))

(defun logview-filter-edit--quit (save)
  (let ((parent  logview-filter-edit--parent-buffer)
        (windows logview-filter-edit--window-configuration)
        (filters (when save
                   (buffer-substring-no-properties 1 (1+ (buffer-size))))))
    (kill-buffer)
    (switch-to-buffer parent)
    (set-window-configuration windows)
    (when save
      (setq logview--current-filter-text filters)
      (logview--parse-filters)
      (logview--apply-parsed-filters))))

(defun logview-filter-edit--initialize-text (text)
  (unless (string-prefix-p logview-filter-edit--hint-comment text)
    (setq text (concat logview-filter-edit--hint-comment text)))
  (delete-region 1 (1+ (buffer-size)))
  (insert text)
  (unless (bolp)
    (insert "\n"))
  ;; Put cursor at the first filter beginning if possible.
  (goto-char 1)
  (logview--iterate-filter-lines (lambda (type _line-begin begin _end)
                                   (if (member type logview--valid-filter-prefixes)
                                       (progn (goto-char begin) nil)
                                     t)))
  (set-buffer-modified-p nil))

(defun logview-filter-edit--font-lock-region (region-begin region-end &optional _old-length)
  (save-excursion
    (save-match-data
      (save-restriction
        (with-silent-modifications
          (widen)
          (goto-char region-begin)
          (forward-line 0)
          ;; Never try to parse from the middle of a multiline filter.
          (while (and (not (bobp))
                      (looking-at "\.\. "))
            (forward-line -1))
          (logview--iterate-filter-lines
           (lambda (type _line-begin begin end)
             (cond ((null type)
                    (put-text-property begin end 'face 'error))
                   ((string= type "#")
                    (put-text-property begin end 'face 'font-lock-comment-face))
                   ((string= type "")
                    (put-text-property begin end 'face nil))
                   (t
                    (let* ((valid (logview--valid-regexp-p (logview--filter-regexp begin end))))
                      (goto-char begin)
                      (while (let ((from (point)))
                               (put-text-property (- from 3) from 'face 'logview-edit-filters-type-prefix)
                               (forward-line)
                               (put-text-property from (if (bolp) (logview--linefeed-back (point)) (point))
                                                  'face (unless valid 'error))
                               (when (< (point) end)
                                 (forward-char 3)
                                 t))))))
             (< (point) region-end))))))))


(provide 'logview)

;;; logview.el ends here
