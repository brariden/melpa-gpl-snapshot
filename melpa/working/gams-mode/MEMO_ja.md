<!--
Author:		     Shiro Takeda
First-written:       <2003/02/21>
Time-stamp:	     <2016-03-16 12:14:24 st>
-->

Memo
============================================================

* Emacs が扱える整数の上限は 2**28 = 268435456
* GAMS の数式を TeX の数式に変換する機能を追加する．
* OUTLINE
  + 数字を表示できるものに関しては数字を表示するようーにする．
* 便利な関数
  + (sit-for 0) は画面を書換えるのに使える。
* `memq`、`member`、`assq`、`assoc` のリスト探索基本関数を使うほうが明示的な繰り
  返しよりも速い。これらの探索基本関数の1つを使えるようにデータ構造を変更する価
  値はある。
  
## 以下は Emacs lisp のマニュアルからの抜粋
     
### 説明文字列に関するヒント

説明文字列を書くうえでのヒントや慣習を述べます。コマンド`M-x
checkdoc-minor-mode`を実行して、これらの慣習の多くを確認できます。

* ユーザーが知っておくことを意図した各コマンド、関数、変数には、説明文字列を付け
  ること。

* Lispプログラムの内部変数やサブルーティンにも説明文字列を付ける。Emacsの初期の
  版では、説明文字列のかわりにコメントを使うと容量を節約できたが、今はこれはあて
  はまらない。

* 説明文字列の最初の行は、1つか2つの完全な文であり、それだけで概要を表しているこ
  と。`M-x apropos`は説明文字列の最初の行だけを表示するため、それだけで十分に表
  せないと表示結果が悪くなる。特に、最初の行は大文字で始め、ピリオドで終えること。

  説明文字列には、関数や変数の使い方の詳細を述べる追加の行があってよい。それらの
  行も完全な文から成るべきであるが、見ためをよくするために適当に詰めてよい。

* 一貫性があるように、関数の説明文字列の最初の文の動詞は『to』を省いた不定詞にす
  る。たとえば、『Returns the cons of A and B.』ではなく『Return the cons of A
  and B.』とする。最初の行の残りの文についても同様にするとよい。以降の文節では適
  切な主語があるほうが一般にはよい。

* 説明文字列は受動態ではなく能動態で書き、未来形ではなく現在形で書く。たとえば、
  『A list containing A and B will be returned.』ではなく『Return a list
  containing A and B.』と書く。

* 不必要に単語『cause』（および同義語）を使わないこと。『Cause Emacs to display
  text in boldface,』ではなく単に『Display text in boldface.』と書く。

* 説明文字列は、白文字で始めたり終えないこと。

* 80コラムのスクリーン上のEmacsのウィンドウに収まるように説明文字列を整形する。
  ほとんどの行を60文字を越えないようにするとよい。必要な情報を入れるためならば最
  初の行が長くなってもよい。

  しかし、説明文字列全体を単純に整形するよりは、注意深く行分けすると読みやすくな
  る。説明文字列が長い場合には、話題ごとに空行で区切る。

* ソースコード上で説明文字列の最初の行に揃えるために説明文字列の残りの行を字下げ
  *しないこと*。ソースコード上では見ためがよくても、ユーザーが説明文字を見るとき
  には奇妙に見える。文字列を始めるダブルクォートのまえにある字下げは文字列の一部
  ではないことに注意！

* ユーザーが禁止コマンドを実行しようとすると、Emacsは当該コマンドの説明文字列の
  最初の文節、つまり、最初の空行までを表示する。必要ならば、最初の空行のまえに入
  れるべき情報を選んで、このような表示が有用であるようにする。

* ユーザーが対話的に設定したがるような変数では、その変数の説明文字列は`*`で始め
  る。変数の値が、長いリストや関数であるとき、あるいは、初期化ファイルでのみ設定
  するような変数であるときには、その説明文字列を`*`で始めないこと。*Note
  Defining Variables::。

* yes/noのフラグを表す変数の説明文字列は『Non-nil means...』のような単語で始めて、
  `nil`以外の値はすべて同値であることを明らかにし、`nil`と`nil`以外の意味を明確
  に示すこと。

* 関数の説明文字列でその引数について述べるときには、その引数の値を表す名前には大
  文字で書いた引数名を使う。したがって、関数`/`の説明文字列では、その第2引数の名
  前は`divisor`なので、`DIVISOR`と表す。

  また、リストやベクトルを（その一部が変化するかもしれない）構成部分に分解したも
  のを示すときなどのメタ変数には、すべて大文字を使う。

* 説明文字列でLispシンボルを参照するときには、それが表示されるとき（つまり普通は
  すべて小文字）のようにシングルクォートで囲って書く。たとえば、`lambda`である。
  これには2つ例外があり、tとnilはシングルクォートで囲まずに書く。（本書では、す
  べてのシンボルをシングルクォートで囲む別の慣習を用いている。）

  ヘルプモードでは、説明文字列でシングルクォートで囲ったシンボルを使うと、そのシ
  ンボルに関数定義や変数定義があるときには自動的にハイパーリンクを作成する。この
  機能を利用するために特別なことをする必要はない。しかし、シンボルに関数定義と変
  数定義の両方があり、どちらか一方のみを参照したい場合には、シンボルの名前のまえ
  に`variable`、`option`、`function`、`command`のいずれかの単語を書くだけでどち
  らであるかを指定できる。（これらの単語を認識するときには大文字小文字は区別しな
  い。）たとえばつぎのように書くと、

        This function sets the variable `buffer-file-name`.

  ハイパーリンクは、変数`buffer-file-name`の説明文字列を指し、その関数の説明文字
  列は指さない。

  シンボルに関数定義や変数定義があっても、説明文字列でのシンボルの使い方には無関
  係な場合には、シンボルの名前のまえに単語`symbol`を書けば、ハイパーリンクを作ら
  ないようにできる。たとえば、つぎのようにすると、

>       If the argument KIND-OF-RESULT is the symbol `list',
>       this function returns a list of all the objects
>       that satisfy the criterion.

  ここでは`list`の関数／変数定義は無関係なので、関数`list`の説明文字列を指すハイ
  パーリンクは作られない。

* 説明文字列に直接キー列を書き込まないこと。そのかわりに、それの標準的なキー列を
  作成する`\\[...]`の書き方を使う。たとえば、`C-f`と書くかわりに、
  `\\[forward-char]`と書く。Emacsが説明文字列を表示するときに、`forward-char`に
  現在バインドされているキーにEmacsが置き換える。（普通は`C-f`であるが、ユーザー
  がキーバインディングを変更していれば、別の文字になる。）*Note Keys in
  Documentation::。

* メジャーモードの説明文字列では、グローバルなキーマップではなくそのモードのロー
  カルなキーマップでのキーバインディングを参照したいだろう。それには、使用するキー
  マップを指定する構文`\\<...>`を説明文字列の中に書く。最初に`\\[...]`を使うまえ
  にこうしておくこと。`\\<...>`の内側のテキストは、メジャーモード向けのローカル
  キーマップを保持する変数の名前であること。

  説明文字列の表示を遅くしてしまうので、`\\[...]`を何回も使うのは実用的ではない。
  したがって、読者のメジャーモードのもっとも重要なコマンドの記述にこれを使い、モー
  ドのキーマップの残りを表示するには`\\{...}`を使う。


### コンパイル済みコードを速くするヒント

バイトコンパイルしたLispプログラムの実行速度を改良する方法を示します。

* ライブラリ`profile`やライブラリ`elp`で、読者のプログラムを計測する。操作方法に
  ついてはファイル`profile.el`と`elp.el`を参照。

* 可能な場合には再帰ではなく繰り返しを使う。コンパイル済みの関数が別のコンパイル
  済み関数を呼び出す場合であってもEmacs Lispでは関数呼び出しは遅い。

* `memq`、`member`、`assq`、`assoc`のリスト探索基本関数を使うほうが明示的な繰り
  返しよりも速い。これらの探索基本関数の1つを使えるようにデータ構造を変更する価
  値はある。

* ある種の組み込み関数は、バイトコンパイル済みのコードでは普通の関数呼び出しを避
  けるように特別に扱われる。これらの関数を使うのはよいことである。コンパイラが関
  数を特別に扱うかどうかを調べるには、その属性`byte-compile`を調べる。属性が
  `nil`以外であれば、その関数は特別に扱われる。

  たとえば、つぎの入力は、`aref`が特別にコンパイルされることを示す（*Note Array
  Functions::）。

        (get 'aref 'byte-compile) => byte-compile-two-args

* 読者のプログラムの実行時間のかなりの部分を小さな関数の呼び出しが占めるときには、
  その関数をインラインにする。これにより関数呼び出しのオーバヘッドを削除できる。
  関数をインラインにするとプログラム変更の柔軟性を減じるので、ユーザーが速度を気
  にするほど遅い部分の十分な速度向上が得られない限り、このようにしないこと。
  *Note Inline Functions::。
  

<!--
--------------------
Local Variables:
mode: markdown
coding: utf-8-dos
fill-column: 74
End:
-->
