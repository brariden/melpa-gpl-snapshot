\input texinfo
@c %**start of header
@setfilename sly.info

@iftex
@documentencoding UTF-8
@codequoteundirected on
@codequotebacktick on
@end iftex

@dircategory Emacs
@direntry
* SLY: (sly).    Common-Lisp IDE
@end direntry
@c %**end of header

@set SLYVER 1.0.0-beta-2
@set UPDATED @today{}
@set TITLE SLY User Manual
@settitle @value{TITLE}, version @value{SLYVER}

@copying
Written by Luke Gorrie and others.

This file has been placed in the public domain.
@end copying

@c For screenshots use

@c (make-frame '((height . 32) (width . 90) (font . "Andale Mono 13")))
@c M-x load-theme RET base16-bright-light RET

@c preferably on Mac OSX, then Cmd-Shift-4 SPC and click the window


@titlepage
@title @value{TITLE}
@sp 10
@center
@example
          _____    __   __  __        
         / ___/   / /   \ \/ /               |\      _,,,---,,_
         \__ \   / /     \  /                /,`.-'`'    -.  ;-;;,_
        ___/ /  / /___   / /                |,4-  ) )-,_..;\ (  `'-'
       /____/  /_____/  /_/                '---''(_/--'  `-'\_)

@end example
@sp 10
@subtitle version @value{SLYVER}
@page
@insertcopying

@end titlepage

@c Macros

@macro SLY
@acronym{SLY}
@end macro

@macro SLY-DB
@acronym{SLY-DB}
@end macro

@macro REPL
@acronym{REPL}
@end macro

@macro Git
@acronym{Git}
@end macro

@macro kbditem{key, command}
@item \key\
@itemx M-x \command\
@kindex \key\
@findex \command\
@c
@end macro

@macro kbditempair{key1, key2, command1, command2}
@item \key1\, M-x \command1\
@itemx \key2\, M-x \command2\
@kindex \key1\
@kindex \key2\
@findex \command1\
@findex \command2\
@c
@end macro

@macro cmditem{command}
@item M-x \command\
@findex \command\
@c
@end macro

@macro kbdanchorc{key, command, comment}
@anchor{\command\}
@item \key\
@code{\command\}
@i{\comment\}@*
@end macro

@macro fcnindex{name}
@item \name\
@xref{\name\}.
@end macro

@c Merge the variable and concept indices because both are rather short
@synindex cp vr


@c @setchapternewpage off
@c @shortcontents
@contents

@ifnottex
@node Top
@top SLY

@SLY{} is a Common Lisp IDE for Emacs. This is the manual for version
@value{SLYVER}. (Last updated @value{UPDATED})

@insertcopying
@end ifnottex

@menu
* Introduction::
* Getting started::
* SLY mode::
* REPL::
* Horizontal Functionality::
* Inspector::
* Debugger::
* Customization::
* Tips and Tricks::
* Extensions::
* Credits::
* Key Index ::
* Command Index::
* Variable Index::
@end menu

@node Introduction
@chapter Introduction

@SLY{} is Sylvester the Cat's Common Lisp IDE. It extends Emacs with
support for interactive programming in Common Lisp.

The features are centered around @code{sly-mode}, an Emacs minor-mode
that complements the standard @code{lisp-mode}. While
@code{lisp-mode} supports editing Lisp source files, @code{sly-mode}
adds support for interacting with a running Common Lisp process for
compilation, debugging, documentation lookup, and so on.

@SLY{} also attempts to follow the example of Emacs's own native Elisp
environment. Many of the keybindings and interface concepts used to
interact with Emacs's Elisp machine are reused in @SLY{} to interact
with the underlying Common Lisp processes.

Internally, @SLY{}'s user-interface, which written in Emacs Lisp, is
connected via a socket to a server program written in Common Lisp, and
makes request to it using an @acronym{RPC}-like protocol. The Lisp
server is primarily written in portable Common Lisp. Some needed
non-standard functionality provided differently by each Lisp
implementation (SBCL, CMUCL, Allegro, etc...) is specified by a
well-defined interface. Each Lisp implementation provides a separate
implementation, making @SLY{} readily portable.

@SLY{} is a direct fork of @acronym{SLIME}, the Superior Lisp
Interaction Mode for Emacs, itself based on previous modes such
as @acronym{SLIM} and @acronym{ILISP}. If you already know
@acronym{SLIME}, @SLY{}'s closeness to is immediately
apparent. However, where @acronym{SLIME} has traditionally focused on
the stability of its core functionality, @SLY{} strives to bring to
the table, by default, a richer feature set brought together by a
consistent user interface.

To understand the differences between the two projects read
@SLY{}'s @uref{https://github.com/capitaomorte/sly/blob/master/NEWS.md,,NEWS.md}
file.

@node Getting started
@chapter Getting started

This chapter tells you how to get @SLY{} up and running.

@menu
* Platforms::
* Downloading::
* Installation::
* Running::
* Basic customization::
* Multiple Lisps::
* Loading Slynk faster::
@end menu

@node Platforms
@section Supported Platforms

@SLY{} supports a wide range of operating systems and Lisp
implementations. @SLY{} runs on Unix systems, Mac OSX, and Microsoft
Windows. GNU Emacs versions 24.3 and above are supported. @emph{XEmacs
or Emacs 23 are notably not supported}.

The supported Lisp implementations, roughly ordered from the
best-supported, are:

@itemize @bullet
@item
CMU Common Lisp (@acronym{CMUCL}), 19d or newer
@item
Steel Bank Common Lisp (@acronym{SBCL}), 1.0 or newer
@item
Clozure Common Lisp (@acronym{CCL}), version 1.3 or newer
@item
LispWorks, version 4.3 or newer
@item
Allegro Common Lisp (@acronym{ACL}), version 6 or newer
@item
@acronym{CLISP}, version 2.35 or newer
@item
Armed Bear Common Lisp (@acronym{ABCL})
@item
Scieneer Common Lisp (@acronym{SCL}), version 1.2.7 or newer
@item
Embedded Common Lisp (@acronym{ECL})
@item
ManKai Common Lisp (@acronym{MKCL})
@item
Clasp
@end itemize

Most features work uniformly across implementations, but some are
prone to variation. These include the precision of placing
compiler-note annotations, @acronym{XREF} support, and fancy debugger
commands (like ``restart frame'').

@node Downloading
@section Downloading SLY

You can choose between using a released version of @SLY{} or accessing
our @Git{} repository directly. You can releases from
@url{https://github.com/capitaomorte/sly/releases}. Alternatively
download the very latest @SLY{}:

@example
git clone https://github.com/capitaomorte/sly.git
@end example

You might substitute @code{https} for @code{http} if you're having
problems with that protocol. To find out what's new since the version
you're currently running, you can use @code{git log}

@example
git fetch origin
git log HEAD..origin/master
@end example

If you want to hack on @SLY{}, use Github's @emph{fork} functionality
and submit a @emph{pull request}. Be sure to first read the
@uref{https://github.com/capitaomorte/sly/blob/master/CONTRIBUTING.md,,CONTRIBUTING.md} file first.

@node Installation
@section Installation

With a Lisp implementation that can be started from the command-line,
installation just requires a few lines in your @file{.emacs}:

@example
(add-to-list 'load-path "~/dir/to/cloned/sly")
(require 'sly-autoloads)
(setq inferior-lisp-program "/opt/sbcl/bin/sbcl")
@end example

After evaluating these three expressions, you should be able to
execute @kbd{M-x sly} and be greeted with a @REPL{}.

@node Running
@section Running SLY

@SLY{} can either ask Emacs starts it's own Lisp subprocesss or
connect to a running process on an arbitrary host and port
combination.

The first alternative is more common and is started via @kbd{M-x sly}:
the ``inferior'' Lisp process thus started is told to load the
Lisp-side server known as ``Slynk''. A socket connection is then
established between Emacs and Lisp. Finally a @REPL{} buffer is
created where you can enter Lisp expressions for evaluation.

The second alternative uses @kbd{M-x sly-connect}. This assumes that
that a Slynk server is running on some local or remote host, and
listening on a given port. @kbd{M-x sly-connect} prompts the user for
these values, and and upon connection the @REPL{} is established.

@node Basic customization
@section Basic customization

To customize a particular binding in one of @SLY{}'s keymaps, you
can add one of the following to your init file:

@example
(eval-after-load 'sly
  `(define-key sly-prefix-map (kbd "M-h") 'sly-documentation-lookup))
@end example

@SLY{} comes bundled with many extensions (called ``contribs'' for
historical reasons) which you can customize just like @SLY{}'s
code. To make @kbd{C-c C-c} clear the last REPL prompt's output, for
example, use

@example
(eval-after-load 'sly-mrepl
   `(define-key sly-mrepl-mode-map (kbd "C-c C-k")
                'sly-mrepl-clear-recent-output))
@end example

To learn about each extension's functionality and its keymap, see
@pxref{Extensions}.

@node Multiple Lisps
@section Multiple Lisps

By default, the command @kbd{M-x sly} starts the program specified
with @code{inferior-lisp-program}.  If you invoke @kbd{M-x sly} with
a prefix argument, Emacs prompts for the program which should be
started instead.  If you need that frequently or if the command
involves long filenames it's more convenient to set the
@code{sly-lisp-implementations} variable in your @file{.emacs}.  For
example here we define two programs:

@lisp
(setq sly-lisp-implementations
      '((cmucl ("cmucl" "-quiet"))
        (sbcl ("/opt/sbcl/bin/sbcl") :coding-system utf-8-unix)))
@end lisp

This variable holds a list of programs and if you invoke @SLY{} with
a negative prefix argument, @kbd{M-- M-x sly}, you can select a
program from that list. When called without a prefix, either the name
specified in @code{sly-default-lisp}, or the first item of the list will be used.
The elements of the list should look like

@lisp
(NAME (PROGRAM PROGRAM-ARGS...) &key CODING-SYSTEM INIT INIT-FUNCTION ENV)
@end lisp

@table @code
@item NAME
is a symbol and is used to identify the program.
@item PROGRAM
is the filename of the program.  Note that the filename can contain
spaces.
@item PROGRAM-ARGS
is a list of command line arguments.
@item CODING-SYSTEM
the coding system for the connection.  (@pxref{sly-net-coding-system})x
@item INIT
should be a function which takes two arguments: a filename and a
character encoding.  The function should return a Lisp expression as a
string which instructs Lisp to start the Slynk server and to write the
port number to the file.  At startup, @SLY{} starts the Lisp process
and sends the result of this function to Lisp's standard input.  As
default, @code{sly-init-command} is used.  An example is shown in
@ref{init-example,,Loading Slynk faster}.
@item INIT-FUNCTION
should be a function which takes no arguments.  It is called after
the connection is established. (See also @ref{sly-connected-hook}.)
@item ENV
specifies a list of environment variables for the subprocess. E.g.
@lisp
(sbcl-cvs ("/home/me/sbcl-cvs/src/runtime/sbcl"
           "--core" "/home/me/sbcl-cvs/output/sbcl.core")
          :env ("SBCL_HOME=/home/me/sbcl-cvs/contrib/"))
@end lisp
initializes @code{SBCL_HOME} in the subprocess.
@end table

@node Loading Slynk faster
@section Loading Slynk faster

In this section, a technique to load Slynk faster on South Bank Common
Lisp (SBCL) is presented.  Similar setups should also work for other
Lisp implementations.

For SBCL, we recommend that you create a custom core file with socket
support and @acronym{POSIX} bindings included because those modules
take the most time to load.  To create such a core, execute the
following steps:

@example
shell$ sbcl
* (mapc 'require '(sb-bsd-sockets sb-posix sb-introspect sb-cltl2 asdf))
* (save-lisp-and-die "sbcl.core-for-sly")
@end example

After that, add something like this to your @file{.emacs}:

@lisp
(setq sly-lisp-implementations
      '((sbcl ("sbcl" "--core" "sbcl.core-for-sly"))))
@end lisp

For maximum startup speed you can include the Slynk server directly in
a core file.  The disadvantage of this approach is that the setup is a
bit more involved and that you need to create a new core file when you
want to update @SLY{} or @acronym{SBCL}.  The steps to execute are:

@example
shell$ sbcl
* (load ".../sly/slynk-loader.lisp")
* (slynk-loader:dump-image "sbcl.core-with-slynk")
@end example

@noindent
Then add this to your @file{.emacs}:

@anchor{init-example}
@lisp
(setq sly-lisp-implementations
      '((sbcl ("sbcl" "--core" "sbcl.core-with-slynk")
              :init (lambda (port-file _)
                      (format "(slynk:start-server %S)\n" port-file)))))
@end lisp

@noindent

@node SLY mode
@chapter Editing Lisp Code

@SLY{}'s commands when editing a Lisp file are provided via
@code{sly-editing-mode}, a minor-mode used in conjunction with Emacs's
@code{lisp-mode}.

This chapter generally describes the actions to working in Lisp source
buffers, though a lot of other functionality in SLY naturally also
applies there (@pxref{Horizontal Functionality}).

@menu
* Evaluation::
* Compilation::
* Autodoc::
* Completion::
* Semantic indentation::
* Reader conditionals::
* Macro-expansion::
@end menu

@node Evaluation
@section Evalutating code

These commands each evaluate a Common Lisp expression in a different
way.  Usually they mimic commands for evaluating Emacs Lisp code.  By
default they show their results in the echo area, but a prefix
argument causes the results to be inserted in the current buffer.

@table @kbd

@kbditem{C-x C-e, sly-eval-last-expression}

Evaluate the expression before point and show the result in the echo
area.

@kbditem{C-M-x, sly-eval-defun}
Evaluate the current toplevel form and show the result in the echo
area.  `C-M-x' treats `defvar' expressions specially.  Normally,
evaluating a `defvar' expression does nothing if the variable it
defines already has a value.  But `C-M-x' unconditionally resets the
variable to the initial value specified in the `defvar' expression.
This special feature is convenient for debugging Lisp programs.

@end table

If @kbd{C-M-x} or @kbd{C-x C-e} is given a numeric argument, it
inserts the value into the current buffer, rather than displaying it
in the echo area.

@table @kbd
@kbditem{C-c :, sly-interactive-eval}
Evaluate an expression read from the minibuffer.

@kbditem{C-c C-r, sly-eval-region}
Evaluate the region.

@kbditem{C-c C-p, sly-pprint-eval-last-expression}
Evaluate the expression before point and pretty-print the result in a
fresh buffer.

@kbditem{C-c E, sly-edit-value}
Edit the value of a setf-able form in a new buffer @file{*Edit <form>*}.
The value is inserted into a temporary buffer for editing and then set
in Lisp when committed with @kbd{C-c C-c}.

@kbditem{C-x M-e, sly-eval-last-expression-display-output}
Display the output buffer and evaluate the expression preceding point.
This is useful if the expression writes something to the output stream.

@kbditem{C-c C-u, sly-undefine-function}
Undefine the function, with @code{fmakunbound}, for the symbol at
point.

@end table

@node Compilation
@section Compiling functions and files

@cindex Compilation

@SLY{} has fancy commands for compiling functions, files, and
packages. The fancy part is that notes and warnings offered by the
Lisp compiler are intercepted and annotated directly onto the
corresponding expressions in the Lisp source buffer. (Give it a try to
see what this means.)

@table @kbd
@cindex Compiling Functions
@kbditem{C-c C-c, sly-compile-defun}
Compile the top-level form at point.  The region blinks shortly to
give some feedback which part was chosen.

With (positive) prefix argument the form is compiled with maximal
debug settings (@kbd{C-u C-c C-c}). With negative prefix argument it is compiled for
speed (@kbd{M-- C-c C-c}). If a numeric argument is passed set debug or speed settings
to it depending on its sign.

The code for the region is executed after compilation.  In principle,
the command writes the region to a file, compiles that file, and loads
the resulting code.

@kbditem{C-c C-k, sly-compile-and-load-file}
Compile and load the current buffer's source file.  If the compilation
step fails, the file is not loaded.  It's not always easy to tell
whether the compilation failed: occasionally you may end up in the
debugger during the load step.

With (positive) prefix argument the file is compiled with maximal
debug settings (@kbd{C-u C-c C-k}). With negative prefix argument it is compiled for
speed (@kbd{M-- C-c C-k}). If a numeric argument is passed set debug or speed settings
to it depending on its sign.

@kbditem{C-c M-k, sly-compile-file}
Compile (but don't load) the current buffer's source file.

@kbditem{C-c C-l, sly-load-file}
Load a Lisp file.  This command uses the Common Lisp LOAD function.

@cmditem{sly-compile-region}
Compile the selected region.

@end table

The annotations are indicated as underlining on source forms. The
compiler message associated with an annotation can be read either by
placing the mouse over the text or with the selection commands below.

@table @kbd
@kbditem{M-n, sly-next-note}
Move the point to the next compiler note and displays the note.

@kbditem{M-p, sly-previous-note}
Move the point to the previous compiler note and displays the note.

@kbditem{C-c M-c, sly-remove-notes}
Remove all annotations from the buffer.

@kbditem{C-x `, next-error}
Visit the next-error message.  This is not actually a @SLY{} command
but @SLY{} creates a hidden buffer so that most of the Compilation
mode commands (@inforef{Compilation Mode,, emacs}) work similarly for
Lisp as for batch compilers.

@end table

@node Autodoc
@section Autodoc

SLY automatically shows information about symbols near the point. For
function names the argument list is displayed, and for global
variables, the value.  Autodoc is implemented by means
of @code{eldoc-mode} of Emacs.

@table @kbd
@cmditem{sly-arglist NAME}
Show the argument list of the function NAME.

@cmditem{sly-autodoc-mode}
Toggles autodoc-mode on or off according to the argument, and
toggles the mode when invoked without argument.
@kbditem{C-c C-d a, sly-autodoc-manually}
Like sly-autodoc, but when called twice,
or after sly-autodoc was already automatically called,
display multiline arglist.
@end table

If the variable @code{sly-use-autodoc-mode} is set (default), Emacs
starts a timer, otherwise the information is only displayed after
pressing SPC.

If @code{sly-autodoc-use-multiline-p} is set to non-nil,
allow long autodoc messages to resize echo area display.

@code{autodoc-mode} is a contrib and can be turned off if you
so wish (@pxref{Extensions})

@node Completion
@section Auto-completion

@cindex Completion
@cindex Symbol Completion

Completion commands are used to complete a symbol or form based on
what is already present at point. Emacs has many completion mechanisms
that @SLY{} tries to mimic as much as possible.

SLY provides two styles of completion. The choice between them happens
in the Emacs customization variable
@pxref{sly-complete-symbol-function}, which can be set to two values.

@enumerate
@item @code{sly-flex-completions}
Use ``flex'' (also sometimes known as ``scatter'' or ``fuzzy'')
completion on a pattern. This method tries hard to search all
available symbols, including symbols not accessible from the current
package, and present them to the user in a list sorted according to
the probable usefulness of the symbol in that context.

@item @code{sly-simple-completions}
Use ``classical'' completion on a prefix. This method is simpler and
more predictable. It's closer to the default Emacs completion method
@end enumerate

As an enhancement in @SLY{} over Emacs' built-in completion styles,
when the @code{*sly-completions*} buffer pops up, the following
keybindings are active momentarily, until the user selects a
completion or gives up:

@table @kbd
@kbditem{C-n, sly-next-completion}
Select the next completion.

@kbditem{C-p, sly-previous-completion}
Select the previous completion.

@kbditem{tab, RET, sly-choose-completion}
Choose the currently selected completion and enter it at point.
@end table

@node Semantic indentation
@section Semantic indentation

@SLY{} automatically discovers how to indent the macros in your Lisp
system. To do this the Lisp side scans all the macros in the system and
reports to Emacs all the ones with @code{&body} arguments. Emacs then
indents these specially, putting the first arguments four spaces in and
the ``body'' arguments just two spaces, as usual.

This should ``just work.'' If you are a lucky sort of person you needn't
read the rest of this section.

To simplify the implementation, @SLY{} doesn't distinguish between
macros with the same symbol-name but different packages. This makes it
fit nicely with Emacs's indentation code. However, if you do have
several macros with the same symbol-name then they will all be indented
the same way, arbitrarily using the style from one of their
arglists. You can find out which symbols are involved in collisions
with:

@example
(slynk:print-indentation-lossage)
@end example

If a collision causes you irritation, don't have a nervous breakdown,
just override the Elisp symbol's @code{common-lisp-indent-function}
property to your taste. @SLY{} won't override your custom settings, it
just tries to give you good defaults.

A more subtle issue is that imperfect caching is used for the sake of
performance. @footnote{@emph{Of course} we made sure it was actually too
slow before making the ugly optimization.}

In an ideal world, Lisp would automatically scan every symbol for
indentation changes after each command from Emacs. However, this is too
expensive to do every time. Instead Lisp usually just scans the symbols
whose home package matches the one used by the Emacs buffer where the
request comes from. That is sufficient to pick up the indentation of
most interactively-defined macros. To catch the rest we make a full scan
of every symbol each time a new Lisp package is created between commands
-- that takes care of things like new systems being loaded.

You can use @kbd{M-x sly-update-indentation} to force all symbols to
be scanned for indentation information.

@node Reader conditionals
@section Reader conditional fontification

@SLY{} automatically evaluates reader-conditional expressions, like
@code{#+linux}, in source buffers and ``grays out'' code that will be
skipped for the current Lisp connection.

@node Macro-expansion
@section Macro-expansion commands

@cindex Macros

@table @kbd
@kbditem{C-c C-m, sly-expand-1}
Macroexpand (or compiler-macroexpand) the expression at point
once.  If invoked with a prefix argument use macroexpand instead or
macroexpand-1 (or compiler-macroexpand instead of
compiler-macroexpand-1).

@cmditem{sly-macroexpand-1}
Macroexpand the expression at point once.  If invoked with a prefix
argument, use macroexpand instead of macroexpand-1.

@kbditem{C-c M-m, sly-macroexpand-all}
Fully macroexpand the expression at point.

@cmditem{sly-compiler-macroexpand-1}
Display the compiler-macro expansion of sexp at point.

@cmditem{sly-compiler-macroexpand}
Repeatedy expand compiler macros of sexp at point.

@end table

Within a sly macroexpansion buffer some extra commands are provided
(these commands are always available but are only bound to keys in a
macroexpansion buffer).

@table @kbd
@kbditem{C-c C-m, sly-macroexpand-1-inplace}
Just like sly-macroexpand-1 but the original form is replaced with
the expansion.

@c @anchor{sly-macroexpand-1-inplace}
@kbditem{g, sly-macroexpand-1-inplace}
The last macroexpansion is performed again, the current contents of
the macroexpansion buffer are replaced with the new expansion.

@kbditem{q, sly-temp-buffer-quit}
Close the expansion buffer.

@kbditem{C-_, sly-macroexpand-undo}
Undo last macroexpansion operation.

@end table

@node REPL
@chapter REPL: the ``top level''

@cindex Listener

@SLY{} uses a custom Read-Eval-Print Loop (@REPL{}, also known as a
``top level'', or listener):

@itemize @bullet
@item
Conditions signalled in @REPL{} expressions are debugged with the
integrated SLY debugger.
@item
Return values are interactive buttons distinguished from printed
output by separate Emacs faces (colours).
@item
Output from the Lisp process is inserted in the right place, and
doesn't get mixed up with user input.
@item
The REPL is a central hub for much of SLY's functionality, since
objects examined in the inspector (@pxref{Inspector}), debugger
(@pxref{Debugger}), and other extensions can be returned there.
@end itemize

@table @kbd

@kbditem{C-c C-z, sly-switch-to-output-buffer}
Select the output buffer, preferably in a different window.

@end table

@menu
* REPL commands::
* Input Navigation::
* REPL output control::
@end menu

@node REPL commands
@section REPL commands

@table @kbd

@kbditem{RET, sly-mrepl-return}

Evaluate the expression at prompt and return the result.

@kbditem{TAB, sly-indent-and-complete-symbol}

Indent the current line. If line already indented complete the symbol at
point. If there is not symbol at point show the argument list of the
most recently enclosed function or macro in the minibuffer.

@kbditem{C-c C-b, sly-interrupt}

Interrupts the current thread of the inferior-lisp process.

For convenience this function is also bound to @kbd{C-c C-c}.

@kbditem{M-p, sly-mrepl-previous-input-or-button}

When at the current prompt fetches to previous input from the history,
otherwise it jumps to the previous button.

@kbditem{M-n, sly-mrepl-next-input-or-button}

When at the current prompt fetches to next input from the history,
otherwise it jumps to the next button.

@kbditem{C-M-p, sly-button-backward}

Go to and describe the previous button in the buffer.

@kbditem{C-M-n, sly-button-forward}

Go to and describe the next button in the buffer.

@end table

@node Input Navigation
@section Input navigation

@cindex Input History

The input navigation (a.k.a. history) commands are modelled after
@code{comint}-mode.

Bash-like keybindings are available: @kbd{M-p} and @kbd{M-n} navigate
the input history incrementally while @kbd{C-r} does a ``reverse
i-search''. @kbd{C-<up>} and @kbd{C-<up>} work like the up and down
keys in Bash.

@table @kbd

@c TODO

@end table

@node REPL output control
@section REPL output control

@itemize
@item @code{SLYNK-MREPL:*GLOBALLY-REDIRECT-IO*}

When true this causes the standard streams (@code{*standard-output*},
etc) to be globally redirected to the @REPL{} in Emacs. When
@code{NIL} (the default) these streams are only temporarily redirected
to Emacs using dynamic bindings while handling requests. Note that
@code{*standard-input*} is currently never globally redirected into
Emacs, because it can interact badly with the Lisp's native @REPL{} by
having it try to read from the Emacs one.

@item @code{SLYNK-MREPL:*USE-DEDICATED-OUTPUT-STREAM*}

This variable controls whether to use a more efficient mechanism for
sending printed output from Lisp to Emacs.

When @code{t}, a separate socket is established solely for Lisp to
send printed output to Emacs through, which is faster than sending the
output in protocol-messages to Emacs.

Notice that using a dedicated output stream also makes it more
difficult to communicate to a Lisp running on a remote host via SSH
(@pxref{Connecting to a remote Lisp}) , so you should probably set
this variable to @code{nil} when doing so.

@item @code{SLYNK:*DEDICATED-OUTPUT-STREAM-PORT*}

When @code{*USE-DEDICATED-OUTPUT-STREAM*} is @code{t} the stream will
be opened on this port. The default value, @code{0}, means that the
stream will be opened on some random port.
@end itemize

@node Horizontal Functionality
@chapter Horizontal Functionality

TODO: introduce this chapter

@menu
* Finding definitions::
* Interactive objects::
* Documentation::
* Multiple connections::
* Disassembly::
* Recovery::
* Other::
* User-interface conventions::
@end menu

@node Finding definitions
@section Navigating code

@subsection Jump to source with @code{M-.}

@cindex Meta-dot
@cindex TAGS

The familiar @kbd{M-.} command is provided. For generic functions this
command finds all methods, and with some systems it does other fancy
things (like tracing structure accessors to their @code{DEFSTRUCT}
definition).

@table @kbd

@kbditem{M-., sly-edit-definition}
Go to the definition of the symbol at point.

@item M-,
@itemx M-*
@itemx M-x sly-pop-find-definition-stack
@kindex M-,
@findex sly-pop-find-definition-stack
Go back to the point where @kbd{M-.} was invoked. This gives multi-level
backtracking when @kbd{M-.} has been used several times.

@kbditem{C-x 4 ., sly-edit-definition-other-window}
Like @code{sly-edit-definition} but switches to the other window to
edit the definition in.

@kbditem{C-x 5 ., sly-edit-definition-other-frame}
Like @code{sly-edit-definition} but opens another frame to edit the
definition in.

@cmditem{sly-edit-definition-with-etags}
Use an ETAGS table to find definition at point.

@end table

@menu
* Cross-reference::
@end menu

@node Cross-reference
@subsection Cross-reference (@acronym{XREF})

@cindex xref
@cindex Cross-referencing

@SLY{}'s cross-reference commands are based on the support provided
by the Lisp system, which varies widely between Lisps. For systems
with no built-in @acronym{XREF} support @SLY{} queries a portable
@acronym{XREF} package, which is taken from the @cite{CMU AI
Repository} and bundled with @SLY{}.

Each command operates on the symbol at point, or prompts if there is
none. With a prefix argument they always prompt. You can either enter
the key bindings as shown here or with the control modified on the
last key, @xref{Key bindings}.

@table @kbd
@kbditem{C-c C-w c, sly-who-calls}
Show function callers.

@kbditem{C-c C-w w, sly-calls-who}
Show all known callees.

@kbditem{C-c C-w r, sly-who-references}
Show references to global variable.

@kbditem{C-c C-w b, sly-who-binds}
Show bindings of a global variable.

@kbditem{C-c C-w s, sly-who-sets}
Show assignments to a global variable.

@kbditem{C-c C-w m, sly-who-macroexpands}
Show expansions of a macro.

@cmditem{sly-who-specializes}
Show all known methods specialized on a class.

@end table

There are also ``List callers/callees'' commands. These operate by
rummaging through function objects on the heap at a low-level to
discover the call graph. They are only available with some Lisp
systems, and are most useful as a fallback when precise @acronym{XREF}
information is unavailable.

@table @kbd
@kbditem{C-c <, sly-list-callers}
List callers of a function.

@kbditem{C-c >, sly-list-callees}
List callees of a function.

@end table

In the resulting @acronym{XREF} buffer, these commands are available:

@table @kbd
@kbditem{RET, sly-show-xref}
Show definition at point in the other window. Do not leave Xref buffer.

@kbditem{Space, sly-goto-xref}
Show definition at point in the other window and close Xref buffer.

@kbditem{C-c C-c, sly-recompile-xref}
Recompile definition at point.

@kbditem{C-c C-c, sly-recompile-all-xrefs}
Recompile all definitions.

@end table

@node Interactive objects
@section Interactive objects

TODO: Write me

@node Documentation
@section Documentation commands

@SLY{}'s online documentation commands follow the example of Emacs
Lisp. The commands all share the common prefix @kbd{C-c C-d} and allow
the final key to be modified or unmodified (@pxref{Key bindings}.)

@table @kbd

@kbditem{SPC, sly-space}
The space key inserts a space, but also looks up and displays the
argument list for the function at point, if there is one.

@kbditem{C-c C-d d, sly-describe-symbol}
Describe the symbol at point.

@kbditem{C-c C-d f, sly-describe-function}
Describe the function at point.

@kbditem{C-c C-d C-a, sly-apropos}
Perform an apropos search on Lisp symbol names for a regular expression
match and display their documentation strings. By default the external
symbols of all packages are searched. With a prefix argument you can choose a
specific package and whether to include unexported symbols.

@kbditem{C-c C-d C-z, sly-apropos-all}
Like @code{sly-apropos} but also includes internal symbols by default.

@kbditem{C-c C-d C-p, sly-apropos-package}
Show apropos results of all symbols in a package. This command is for
browsing a package at a high-level. With package-name completion it
also serves as a rudimentary Smalltalk-ish image-browser.

@kbditem{C-c C-d C-h, sly-hyperspec-lookup}
Lookup the symbol at point in the @cite{Common Lisp Hyperspec}. This
uses the familiar @file{hyperspec.el} to show the appropriate section
in a web browser. The Hyperspec is found either on the Web or in
@code{common-lisp-hyperspec-root}, and the browser is selected by
@code{browse-url-browser-function}.

Note: this is one case where @kbd{C-c C-d h} is @emph{not} the same as
@kbd{C-c C-d C-h}.

@kbditem{C-c C-d ~, hyperspec-lookup-format}
Lookup a @emph{format character} in the @cite{Common Lisp Hyperspec}.

@kbditem{C-c C-d #, hyperspec-lookup-reader-macro}
Lookup a @emph{reader macro} in the @cite{Common Lisp Hyperspec}.
@end table

@node Multiple connections
@section Multiple connections

@SLY{} is able to connect to multiple Lisp processes at the same
time. The @kbd{M-x sly} command, when invoked with a prefix
argument, will offer to create an additional Lisp process if one is
already running. This is often convenient, but it requires some
understanding to make sure that your @SLY{} commands execute in the
Lisp that you expect them to.

Some buffers are tied to specific Lisp processes. Each Lisp connection
has its own @acronym{REPL} buffer, and all expressions entered or
@SLY{} commands invoked in that buffer are sent to the associated
connection. Other buffers created by @SLY{} are similarly tied to
the connections they originate from, including @SLY-DB{} buffers,
apropos result listings, and so on. These buffers are the result of
some interaction with a Lisp process, so commands in them always go
back to that same process.

Commands executed in other places, such as @code{sly-mode} source
buffers, always use the ``default'' connection. Usually this is the
most recently established connection, but this can be reassigned via
the ``connection list'' buffer:

@table @kbd
@kbditem{C-c C-x c, sly-list-connections}
Pop up a buffer listing the established connections. 

@kbditem{C-c C-x n, sly-next-connection}
Switch to the next Lisp connection by cycling through all connections.

@kbditem{C-c C-x p, sly-prev-connection}
Switch to the previous Lisp connection by cycling through all connections.  

@kbditem{C-c C-x t, sly-list-threads}
Pop up a buffer listing the current threads.

@end table

The buffer displayed by @code{sly-list-connections} gives a one-line
summary of each connection. The summary shows the connection's serial
number, the name of the Lisp implementation, and other details of the
Lisp process. The current ``default'' connection is indicated with an
asterisk.

The commands available in the connection-list buffer are:

@table @kbd
@kbditem{RET, sly-goto-connection}
Pop to the @acronym{REPL} buffer of the connection at point.

@kbditem{d, sly-connection-list-make-default}
Make the connection at point the ``default'' connection. It will then
be used for commands in @code{sly-mode} source buffers.

@kbditem{g, sly-update-connection-list}
Update the connection list in the buffer.

@kbditem{q, sly-temp-buffer-quit}
Quit the connection list (kill buffer, restore window configuration).

@kbditem{R, sly-restart-connection-at-point}
Restart the Lisp process for the connection at point.

@cmditem{sly-connect}
Connect to a running Slynk server.

@cmditem{sly-disconnect}
Disconnect all connections.

@cmditem{sly-abort-connection}
Abort the current attempt to connect.

@end table

@node Disassembly
@section Disassembly commands

@table @kbd

@kbditem{C-c M-d, sly-disassemble-symbol}
Disassemble the function definition of the symbol at point.

@kbditem{C-c C-t, sly-toggle-trace-fdefinition}
Toggle tracing of the function at point.  If invoked with a prefix
argument, read additional information, like which particular method
should be traced.

@cmditem{sly-untrace-all}
Untrace all functions.

@end table

@node Recovery
@section Abort/Recovery commands

@table @kbd
@kbditem{C-c C-b, sly-interrupt}
Interrupt Lisp (send @code{SIGINT}).

@cmditem{sly-restart-inferior-lisp}
Restart the @code{inferior-lisp} process.

@kbditem{C-c ~, sly-sync-package-and-default-directory}
Synchronize the current package and working directory from Emacs to
Lisp.

@kbditem{C-c M-p, sly-mrepl-set-package}
Set the current package of the @acronym{REPL}.

@cmditem{sly-cd}
Set the current directory of the Lisp process.  This also
changes the current directory of the REPL buffer.

@cmditem{sly-pwd}
Print the current directory of the Lisp process.

@end table

@node Other
@section Shadowed Commands

@table @kbd

@kbditempair{C-c C-a, C-c C-v, sly-nop, sly-nop}
This key-binding is shadowed from inf-lisp.

@end table

@node User-interface conventions
@section User-interface conventions

To use @SLY{} comfortably it is important to understand a few
``global'' user-interface characteristics. The most important
principles are described in this section.

@menu
* Temporary buffers::
* Multithreading::
* Key bindings::
@end menu

@node Temporary buffers
@subsection Temporary buffers

Some @SLY{} commands create temporary buffers to display their
results. Although these buffers usually have their own special-purpose
major-modes, certain conventions are observed throughout.

Temporary buffers can be dismissed by pressing @kbd{q}. This kills the
buffer and restores the window configuration as it was before the
buffer was displayed. Temporary buffers can also be killed with the
usual commands like @code{kill-buffer}, in which case the previous
window configuration won't be restored.

Pressing @kbd{RET} is supposed to ``do the most obvious useful
thing.'' For instance, in an apropos buffer this prints a full
description of the symbol at point, and in an @acronym{XREF} buffer it
displays the source code for the reference at point. This convention
is inherited from Emacs's own buffers for apropos listings,
compilation results, etc.

Temporary buffers containing Lisp symbols use @code{sly-mode} in
addition to any special mode of their own. This makes the usual
@SLY{} commands available for describing symbols, looking up
function definitions, and so on.

Initial focus of those ``description'' buffers depends on the variable
@code{sly-description-autofocus}. If @code{nil} (the default),
description buffers do not receive focus automatically, and vice
versa.

@node Multithreading
@subsection Multithreading

If the Lisp system supports multithreading, SLY spawns a new thread
for each request, e.g., @kbd{C-x C-e} creates a new thread to evaluate
the expression.  An exception to this rule are requests from the
@REPL{}: all commands entered in the @REPL{} buffer are evaluated in a
dedicated @REPL{} thread.

Some complications arise with multithreading and special variables.
Non-global special bindings are thread-local, e.g., changing the value
of a let bound special variable in one thread has no effect on the
binding of the variables with the same name in other threads.  This
makes it sometimes difficult to change the printer or reader behaviour
for new threads.  The variable
@code{slynk:*default-worker-thread-bindings*} was introduced for such
situations: instead of modifying the global value of a variable, add a
binding the @code{slynk:*default-worker-thread-bindings*}.  E.g., with
the following code, new threads will read floating point values as
doubles by default:

@example
(push '(*read-default-float-format* . double-float)
       slynk:*default-worker-thread-bindings*).
@end example


@node Key bindings
@subsection Key bindings

In general we try to make our key bindings fit with the overall Emacs
style. We also have the following somewhat unusual convention of our
own: when entering a three-key sequence, the final key can be pressed
either with control or unmodified. For example, the
@code{sly-describe-symbol} command is bound to @kbd{C-c C-d d}, but
it also works to type @kbd{C-c C-d C-d}. We're simply binding both key
sequences because some people like to hold control for all three keys
and others don't, and with the two-key prefix we're not afraid of
running out of keys.

There is one exception to this rule, just to trip you up. We never
bind @kbd{C-h} anywhere in a key sequence, so @kbd{C-c C-d C-h}
doesn't do the same thing as @kbd{C-c C-d h}. This is because Emacs
has a built-in default so that typing a prefix followed by @kbd{C-h}
will display all bindings starting with that prefix, so @kbd{C-c C-d
C-h} will actually list the bindings for all documentation commands.
This feature is just a bit too useful to clobber!

@quotation
@i{``Are you deliberately spiting Emacs's brilliant online help facilities? The gods will be angry!''}
@end quotation

@noindent This is a brilliant piece of advice. The Emacs online help facilities
are your most immediate, up-to-date and complete resource for keybinding
information. They are your friends:

@table @kbd
@kbdanchorc{C-h k <key>, describe-key, ``What does this key do?''}
Describes current function bound to @kbd{<key>} for focus buffer.

@kbdanchorc{C-h b, describe-bindings, ``Exactly what bindings are available?''}
Lists the current key-bindings for the focus buffer.

@kbdanchorc{C-h m, describe-mode, ``Tell me all about this mode''}
Shows all the available major mode keys, then the minor mode keys, for
the modes of the focus buffer.

@kbdanchorc{C-h l, view-lossage, ``Woah@comma{} what key chord did I just do?''}
Shows you the literal sequence of keys you've pressed in order.

@c <key> is breaks links PDF, despite that it's not l it's C-h
@c @kbdanchorc{ <key> l, , ``What starts with?''}
@c Lists all keybindings that begin with @code{<key>} for the focus buffer mode.


@end table

@emph{Note:} In this documentation the designation @kbd{C-h} is a
@dfn{canonical key} which might actually mean Ctrl-h, or F1, or
whatever you have @code{help-command} bound to in your
@code{.emacs}. Here is a common situation:

@example
(global-set-key [f1]   'help-command)
(global-set-key "\C-h" 'delete-backward-char)
@end example

@noindent In this situation everywhere you see @kbd{C-h} in the
documentation you would substitute @kbd{F1}.

You can assign or change default key bindings globally using the
@code{global-set-key} function in your @file{~/.emacs} file like this:
@example
(global-set-key "\C-c s" 'sly-mrepl-new)
@end example
@noindent
which binds @kbd{C-c s} to the function @code{sly-mrepl-new}, which
creates a new @REPL{}.

Alternatively, if you want to assign or change a key binding in just a
particular sly mode, you can use the @code{define-key} function
in your @file{~/.emacs} file like this:
@example
(define-key sly-mrepl-mode-map (kbd "C-c ;")
            'sly-insert-balanced-comments)
@end example
@noindent
which binds @kbd{C-c ;} to the function
@code{sly-insert-balanced-comments} in the REPL buffer.

@node Inspector
@chapter The Inspector

The @SLY{} inspector is a Emacs-based alternative to the
standard @code{INSPECT} function. The inspector presents objects in
Emacs buffers using a combination of plain text, hyperlinks to related
objects.

The inspector can easily be specialized for the objects in your own
programs. For details see the @code{inspect-for-emacs} generic
function in @file{slynk-backend.lisp}.

@table @kbd

@kbditem{C-c I, sly-inspect}
Inspect the value of an expression entered in the minibuffer.

@end table

The standard commands available in the inspector are:

@table @kbd

@kbditem{RET, sly-inspector-operate-on-point}
If point is on a value then recursively call the inspector on that
value. If point is on an action then call that action.

@kbditem{d, sly-inspector-describe}
Describe the slot at point.

@kbditem{e, sly-inspector-eval}
Evaluate an expression in the context of the inspected object.

@kbditem{v, sly-inspector-toggle-verbose}
Toggle between verbose and terse mode. Default is determined by
`slynk:*inspector-verbose*'.

@kbditem{l, sly-inspector-pop}
Go back to the previous object (return from @kbd{RET}).

@kbditem{n, sly-inspector-next}
The inverse of @kbd{l}. Also bound to @kbd{SPC}.

@kbditem{g, sly-inspector-reinspect}
Reinspect.

@kbditem{q, sly-inspector-quit}
Dismiss the inspector buffer.

@kbditem{p, sly-inspector-pprint}
Pretty print in another buffer object at point.

@kbditem{., sly-inspector-show-source}
Find source of object at point.

@kbditem{>, sly-inspector-fetch-all}
Fetch all inspector contents and go to the end.

@kbditem{M-RET, sly-inspector-copy-down}
Store the value under point in the variable `*'.  This can
then be used to access the object in the REPL.

@kbditempair{TAB, S-TAB, sly-inspector-next-inspectable-object,
sly-inspector-previous-inspectable-object}

Jump to the next and previous inspectable object respectively.

@end table

@node Debugger
@chapter The Debugger

@cindex Debugger

@SLY{} has a custom Emacs-based debugger called @SLY-DB{}. Conditions
signalled in the Lisp system invoke @SLY-DB{} in Emacs by way of the
Lisp @code{*DEBUGGER-HOOK*}.

@SLY-DB{} pops up a buffer when a condition is signalled. The buffer
displays a description of the condition, a list of restarts, and a
backtrace. Commands are offered for invoking restarts, examining the
backtrace, and poking around in stack frames.

@menu
* Examining frames::
* Restarts::
* Frame Navigation::
* Stepping::
* Miscellaneous::
@end menu

@node Examining frames
@section Examining frames

Commands for examining the stack frame at point.

@table @kbd
@kbditem{t, sly-db-toggle-details}
Toggle display of local variables and @code{CATCH} tags.

@kbditem{v, sly-db-show-source}
View the frame's current source expression. The expression is
presented in the Lisp source file's buffer.

@kbditem{e, sly-db-eval-in-frame}
Evaluate an expression in the frame. The expression can refer to the
available local variables in the frame.

@kbditem{d, sly-db-pprint-eval-in-frame}
Evaluate an expression in the frame and pretty-print the result in a
temporary buffer.

@kbditem{D, sly-db-disassemble}
Disassemble the frame's function. Includes information such as the
instruction pointer within the frame.

@kbditem{i, sly-db-inspect-in-frame}
Inspect the result of evaluating an expression in the frame.

@kbditem{C-c C-c, sly-db-recompile-frame-source}
Recompile frame. @kbd{C-u C-c C-c} for recompiling with maximum debug settings.

@end table

@node Restarts
@section Invoking restarts

@table @kbd
@kbditem{a, sly-db-abort}
Invoke the @code{ABORT} restart.

@anchor{sly-db-quit}
@kbditem{q, sly-db-quit}
``Quit'' -- For @SLY{} evaluation requests, invoke a restart which
restores to a known program state. For errors in other threads, see
@ref{SLYNK:*SLY-DB-QUIT-RESTART*}.

@kbditem{c, sly-db-continue}
Invoke the @code{CONTINUE} restart.

@item 0 ... 9
Invoke a restart by number.
@end table

Restarts can also be invoked by pressing @kbd{RET} or @kbd{Mouse-2} on
them in the buffer.

@node Frame Navigation
@section Navigating between frames

@table @kbd
@kbditempair{n,p,sly-db-down,sly-db-up}
Move between frames.

@kbditempair{M-n, M-p, sly-db-details-down, sly-db-details-up}
Move between frames ``with sugar'': hide the details of the original
frame and display the details and source code of the next. Sugared
motion makes you see the details and source code for the current frame
only.

@kbditem{>, sly-db-end-of-backtrace}
Fetch the entire backtrace and go to the last frame.

@kbditem{<, sly-db-beginning-of-backtrace}
Goto the first frame.

@end table

@node Stepping
@section Stepping

@cindex Stepping

Stepping is not available in all implementations and works very
differently in those in which it is available.

@table @kbd
@kbditem{s, sly-db-step}
Step to the next expression in the frame.  For CMUCL that means, set a
breakpoint at all those code locations in the current code block which
are reachable from the current code location.

@kbditem{x, sly-db-next}
Step to the next form in the current function.

@kbditem{o, sly-db-out}
Stop single-stepping temporarily, but resume it once the current
function returns.

@end table

@node Miscellaneous
@section Miscellaneous Commands

@table @kbd
@kbditem{r, sly-db-restart-frame}
Restart execution of the frame with the same arguments it was
originally called with. (This command is not available in all
implementations.)

@kbditem{R, sly-db-return-from-frame}
Return from the frame with a value entered in the minibuffer. (This
command is not available in all implementations.)


@kbditem{B, sly-db-break-with-default-debugger}
Exit @SLY-DB{} and debug the condition using the Lisp system's default
debugger.

@kbditem{C, sly-db-inspect-condition}
Inspect the condition currently being debugged.

@kbditem{:, sly-interactive-eval}
Evaluate an expression entered in the minibuffer.
@kbditem{A, sly-db-break-with-system-debugger}
Attach debugger (e.g. gdb) to the current lisp process.

@end table

@node Customization
@chapter Customization

@menu
* Emacs-side customization::
* Lisp-side::
@end menu

@node Emacs-side customization
@section Emacs-side

The Emacs part of @SLY{} can be configured with the Emacs
@code{customize} system, just use @kbd{M-x customize-group sly
RET}. Because the customize system is self-describing, we only cover a
few important or obscure configuration options here in the manual.

@table @code

@item sly-truncate-lines
The value to use for @code{truncate-lines} in line-by-line summary
buffers popped up by @SLY{}. This is @code{t} by default, which
ensures that lines do not wrap in backtraces, apropos listings, and so
on. It can however cause information to spill off the screen.

@anchor{sly-complete-symbol-function}
@item sly-complete-symbol-function
The function to use for completion of Lisp symbols. Two completion
styles are available: @code{sly-simple-completions}
and @code{sly-flex-completions} (@pxref{Completion}).

@item sly-filename-translations
This variable controls filename translation between Emacs and the Lisp
system. It is useful if you run Emacs and Lisp on separate machines
which don't share a common file system or if they share the filesystem
but have different layouts, as is the case with @acronym{SMB}-based
file sharing.

@anchor{sly-net-coding-system}
@cindex Unicode
@cindex UTF-8
@cindex ASCII
@cindex LATIN-1
@cindex Character Encoding
@item sly-net-coding-system
If you want to transmit Unicode characters between Emacs and the Lisp
system, you should customize this variable.  E.g., if you use SBCL, you
can set:
@example
(setq sly-net-coding-system 'utf-8-unix)
@end example
To actually display Unicode characters you also need appropriate
fonts, otherwise the characters will be rendered as hollow boxes.  If
you are using Allegro CL and GNU Emacs, you can also
use @code{emacs-mule-unix} as coding system.  GNU Emacs has often
nicer fonts for the latter encoding.  (Different encodings can be used
for different Lisps, see @ref{Multiple Lisps}.)

@end table

@menu
* Hooks::
@end menu

@node Hooks
@subsection Hooks

@table @code

@item sly-mode-hook
This hook is run each time a buffer enters @code{sly-mode}. It is
most useful for setting buffer-local configuration in your Lisp source
buffers. An example use is to enable @code{sly-autodoc-mode}
(@pxref{Autodoc}).

@anchor{sly-connected-hook}
@item sly-connected-hook
This hook is run when @SLY{} establishes a connection to a Lisp
server. An example use is to pop to a new @REPL{}.

@item sly-db-hook
This hook is run after @SLY-DB{} is invoked. The hook functions are
called from the @SLY-DB{} buffer after it is initialized. An example use
is to add @code{sly-db-print-condition} to this hook, which makes all
conditions debugged with @SLY-DB{} be recorded in the @REPL{} buffer.

@end table

@node Lisp-side
@section Lisp-side (Slynk)

The Lisp server side of @SLY{} (known as ``Slynk'') offers several
variables to configure. The initialization file @file{~/.slynk.lisp}
is automatically evaluated at startup and can be used to set these
variables.

@menu
* Communication style::
* Other configurables::
@end menu

@node Communication style
@subsection Communication style

The most important configurable is @code{SLYNK:*COMMUNICATION-STYLE*},
which specifies the mechanism by which Lisp reads and processes
protocol messages from Emacs. The choice of communication style has a
global influence on @SLY{}'s operation.

The available communication styles are:

@table @code
@item NIL
This style simply loops reading input from the communication socket
and serves @SLY{} protocol events as they arise. The simplicity
means that the Lisp cannot do any other processing while under
@SLY{}'s control.

@item :FD-HANDLER
This style uses the classical Unix-style ``@code{select()}-loop.''
Slynk registers the communication socket with an event-dispatching
framework (such as @code{SERVE-EVENT} in @acronym{CMUCL} and
@acronym{SBCL}) and receives a callback when data is available. In
this style requests from Emacs are only detected and processed when
Lisp enters the event-loop. This style is simple and predictable.

@item :SIGIO
This style uses @dfn{signal-driven I/O} with a @code{SIGIO} signal
handler. Lisp receives requests from Emacs along with a signal,
causing it to interrupt whatever it is doing to serve the
request. This style has the advantage of responsiveness, since Emacs
can perform operations in Lisp even while it is busy doing other
things. It also allows Emacs to issue requests concurrently, e.g. to
send one long-running request (like compilation) and then interrupt
that with several short requests before it completes. The
disadvantages are that it may conflict with other uses of @code{SIGIO}
by Lisp code, and it may cause untold havoc by interrupting Lisp at an
awkward moment.

@item :SPAWN
This style uses multiprocessing support in the Lisp system to execute
each request in a separate thread. This style has similar properties
to @code{:SIGIO}, but it does not use signals and all requests issued
by Emacs can be executed in parallel.

@end table

The default request handling style is chosen according to the
capabilities of your Lisp system. The general order of preference is
@code{:SPAWN}, then @code{:SIGIO}, then @code{:FD-HANDLER}, with
@code{NIL} as a last resort. You can check the default style by
calling @code{SLYNK-BACKEND::PREFERRED-COMMUNICATION-STYLE}. You can
also override the default by setting
@code{SLYNK:*COMMUNICATION-STYLE*} in your Slynk init file.

@node Other configurables
@subsection Other configurables

These Lisp variables can be configured via your @file{~/.slynk.lisp}
file:

@table @code

@item SLYNK:*CONFIGURE-EMACS-INDENTATION*
This variable controls whether indentation styles for
@code{&body}-arguments in macros are discovered and sent to Emacs. It
is enabled by default.

@item SLYNK:*GLOBAL-DEBUGGER*
When true (the default) this causes @code{*DEBUGGER-HOOK*} to be
globally set to @code{SLYNK:SLYNK-DEBUGGER-HOOK} and thus for @SLY{}
to handle all debugging in the Lisp image. This is for debugging
multithreaded and callback-driven applications.

@anchor{SLYNK:*SLY-DB-QUIT-RESTART*}
@item SLYNK:*SLY-DB-QUIT-RESTART*
This variable names the restart that is invoked when pressing @kbd{q}
(@pxref{sly-db-quit}) in @SLY-DB{}. For @SLY{} evaluation requests this
is @emph{unconditionally} bound to a restart that returns to a safe
point. This variable is supposed to customize what @kbd{q} does if an
application's thread lands into the debugger (see
@code{SLYNK:*GLOBAL-DEBUGGER*}).
@example
(setf slynk:*sly-db-quit-restart* 'sb-thread:terminate-thread)
@end example

@item SLYNK:*BACKTRACE-PRINTER-BINDINGS*
@itemx SLYNK:*MACROEXPAND-PRINTER-BINDINGS*
@itemx SLYNK:*SLY-DB-PRINTER-BINDINGS*
@itemx SLYNK:*SLYNK-PPRINT-BINDINGS*
These variables can be used to customize the printer in various
situations.  The values of the variables are association lists of
printer variable names with the corresponding value.  E.g., to enable
the pretty printer for formatting backtraces in @SLY-DB{}, you can use:
@example
(push '(*print-pretty* . t) slynk:*sly-db-printer-bindings*).
@end example

@item SLYNK:*ECHO-NUMBER-ALIST*
@itemx SLYNK:*PRESENT-NUMBER-ALIST*
These variables hold function designators used for displaying numbers
in certain contexts of SLY client.

The difference between the two is that @code{*PRESENT-NUMBER-ALIST*}
overrides @code{*ECHO-NUMBER-ALIST*} for the @pxref{REPL}, @pxref{SLY
Trace Dialog} and @pxref{SLY Stickers} context, while the latter is
always used for @pxref{Evaluation} commands like @kbd{C-x C-e}

Both variables have the same structure: each element in the alist
takes the form (TYPE . FUNCTIONS), where TYPE is a type designator and
FUNCTIONS is a list of function designators for displaying that number
in SLY. Each function takes the number as a single argument and
returns a string, or nil, if that particular representation is to be
disregarded.

Additionally if a given function chooses to return @code{t} as its
optional second value, then all the remaining functions following it
in the list are disregarded.

For integer numbers, the default value of this variable holds function
designators that echo an integer number in its binary, hexadecimal and
octal representation. However, if your application is using integers
to represent
@uref{https://en.wikipedia.org/wiki/Unix_time,,Unix Epoch Times} you
can use this function to display a human-readable time
whenever you evaluate an integer.

@example
(defparameter *day-names* '("Monday" "Tuesday" "Wednesday"
                            "Thursday" "Friday" "Saturday"
                            "Sunday"))

(defun fancy-unix-epoch-time (integer)
  "Format INTEGER as a Unix Epoch Time if within 10 years from now."
  (let ((now (get-universal-time))
        (tenyears (encode-universal-time 0 0 0 1 1 1910 0))
        (unix-to-universal
          (+ integer
             (encode-universal-time 0 0 0 1 1 1970 0))))
    (when (< (- now tenyears) unix-to-universal (+ now tenyears))
      (multiple-value-bind
            (second minute hour date month year day-of-week dst-p tz)
          (decode-universal-time unix-to-universal)
        (declare (ignore dst-p))
        (format nil "~2,'0d:~2,'0d:~2,'0d on ~a, ~d/~2,'0d/~d (GMT~@@d)"
                hour minute second (nth day-of-week *day-names*)
                month date year (- tz))))))

(pushnew 'fancy-unix-epoch-time
         (cdr (assoc 'integer slynk:*echo-number-alist*)))

42 ; => 42 (6 bits, #x2A, #o52, #b101010)
1451404675 ; => 1451404675 (15:57:55 on Tuesday, 12/29/2015 (GMT+0), 31 bits, #x5682AD83)
@end example

@item SLYNK:*EXCLUDE-SYMBOL-FUNCTIONS*
This variable holds a list of functions used for excluding certain
symbols from functionality like \"apropos\"" listings (see
@pxref{Documentation}) or @pxref{Completion} listings. By default, it
contains a single function that excludes symbols with names so long
and contorted they wouldn't fit properly in the completions window.

@item SLYNK:*LOG-EVENTS*
Setting this variable to @code{t} causes all protocol messages
exchanged with Emacs to be printed to @code{*TERMINAL-IO*}. This is
useful for low-level debugging and for observing how @SLY{} works
``on the wire.'' The output of @code{*TERMINAL-IO*} can be found in
your Lisp system's own listener, usually in the buffer
@code{*inferior-lisp*}.

@end table

@node Tips and Tricks
@chapter Tips and Tricks

@menu
* Connecting to a remote Lisp::
* Global IO Redirection::
* Auto-SLY::
@end menu

@node Connecting to a remote Lisp
@section Connecting to a remote Lisp

One of the advantages of the way @SLY{} is implemented is that we can
easily run the Emacs side (@code{sly.el} and friends) on one machine
and the Lisp backend (Slynk) on another. The basic idea is to start up
Lisp on the remote machine, load Slynk and wait for incoming @SLY{}
connections. On the local machine we start up Emacs and tell @SLY{} to
connect to the remote machine. The details are a bit messier but the
underlying idea is that simple.

@menu
* Setting up the Lisp image::
* Setting up Emacs::
* Setting up pathname translations::
@end menu

@node Setting up the Lisp image
@subsection Setting up the Lisp image

The easiest way to load Slynk ``standalone'' (i.e. without
having @code{M-x sly} start a Lisp that is subsidiary to a particular
Emacs), is to load the ASDF system definition for Slynk.

Make sure the path to the directory containing Slynk's @code{.asd}
file is in @code{ASDF:*CENTRAL-REGISTRY*}. This file lives in
the @code{slynk} subdirectory of @SLY{}. Type:

@example
(push #p"/path/to/sly/slynk/" ASDF:*CENTRAL-REGISTRY*)
(asdf:require-system :slynk)
@end example

inside a running Lisp image@footnote{@SLY{} also SLIME's old-style
@code{slynk-loader.lisp} loader which does the same thing, but ASDF is preferred}.

Now all we need to do is startup our Slynk server. A working example
uses the default settings:

@example
(slynk:create-server)
@end example

This creates a ``one-connection-only'' server on port 4005 using the
preffered communication style for your Lisp system. The following
parameters to @code{slynk:create-server} can be used to change that
behaviour:

@table @code
@item :PORT
Port number for the server to listen on (default: 4005).
@item :DONT-CLOSE
Boolean indicating if the server will continue to accept connections
after the first one (default: @code{NIL}). For ``long-running'' Lisp processes
to which you want to be able to connect from time to time,
specify @code{:dont-close t}
@item :STYLE
See @xref{Communication style}.
@end table

So a more complete example will be
@example
(slynk:create-server :port 4006  :dont-close t)
@end example

Finally, since section we're going to be tunneling our connection via
@acronym{SSH}@footnote{there is a way to connect without an SSH
tunnel, but it has the side-effect of giving the entire world access
to your Lisp image, so we're not going to talk about it} we'll only
have one port open we must tell Slynk's REPL contrib (see @REPL{}) to
not use an extra connection for output, which it will do by default.

@example
(setf slynk-mrepl:*use-dedicated-output-stream* nil)
@end example

@footnote{Alternatively, a separate tunnel for the port set in
@code{slynk-mrepl:*dedicated-stream-port*} can also be used if a dedicated output
is essential.}

@node Setting up Emacs
@subsection Setting up Emacs

Now we need to create the tunnel between the local machine and the
remote machine. Assumind a @acronym{UNIX} command-line, this can be
done with:

@example
ssh -L4005:127.0.0.1:4005 youruser@@remote.example.com
@end example

This incantation creates a SSH tunnel between the port 4005 on our
local machine and the port 4005 on the remote machine,
where @code{youruser} is expected to have an account.  @footnote{By
default Slynk listens for incoming connections on port 4005, had we
passed a @code{:port} parameter to @code{slynk:create-server} we'd be
using that port number instead}.

Finally we start @SLY{} with @code{sly-connect} instead of the usual
@code{sly}:

@example
M-x sly-connect RET RET
@end example

The @kbd{RET RET} sequence just means that we want to use the default
host (@code{127.0.0.1}) and the default port (@code{4005}). Even
though we're connecting to a remote machine the SSH tunnel fools Emacs
into thinking it's actually @code{127.0.0.1}.

@node Setting up pathname translations
@subsection Setting up pathname translations

One of the main problems with running slynk remotely is that Emacs
assumes the files can be found using normal filenames. if we want
things like @code{sly-compile-and-load-file} (@kbd{C-c C-k}) and
@code{sly-edit-definition} (@kbd{M-.}) to work correctly we need to
find a way to let our local Emacs refer to remote files.

There are, mainly, two ways to do this. The first is to mount, using
NFS or similar, the remote machine's hard disk on the local machine's
file system in such a fashion that a filename like
@file{/opt/project/source.lisp} refers to the same file on both
machines. Unfortunately NFS is usually slow, often buggy, and not
always feasible. Fortunately we have an ssh connection and Emacs'
@code{tramp-mode} can do the rest.
(See @inforef{Top, TRAMP User Manual,tramp}.)

What we do is teach Emacs how to take a filename on the remote machine
and translate it into something that tramp can understand and access
(and vice versa). Assuming the remote machine's host name is
@code{remote.example.com}, @code{cl:machine-instance} returns
``remote'' and we login as the user ``user'' we can use @code{sly-tramp}
contrib to setup the proper translations by simply doing:

@example
(add-to-list 'sly-filename-translations
             (sly-create-filename-translator
              :machine-instance "remote"
              :remote-host "remote.example.com"
              :username "user"))
@end example

@node Global IO Redirection
@section Globally redirecting all IO to the REPL

By default @SLY{} does not change @code{*standard-output*} and
friends outside of the @REPL{}. If you have any other threads which
call @code{format}, @code{write-string}, etc. that output will be seen
only in the @code{*inferior-lisp*} buffer or on the terminal, more
often than not this is inconvenient. So, if you want code such as this:

@example
(run-in-new-thread
  (lambda ()
    (write-line "In some random thread.~%" *standard-output*)))
@end example

to send its output to @SLY{}'s REPL buffer, as opposed to
@code{*inferior-lisp*}, set @code{slynk-mrepl:*globally-redirect-io*}
to T in your @file{~/.slynk.lisp} file.

@node Auto-SLY
@section Connecting to SLY automatically

To make @SLY{} connect to your lisp whenever you open a lisp file
just add this to your @file{.emacs}:

@example
(add-hook 'sly-mode-hook
          (lambda ()
            (unless (sly-connected-p)
              (save-excursion (sly)))))
@end example

@node Extensions
@chapter Extensions

In version 2.1 we moved some functionality to separate packages.  This
chapter tells you how to load contrib modules and describes what the
particular packages do.

@menu
* SLY Stickers::
* SLY Trace Dialog::
* TRAMP Support::
* Scratch Buffer::
* Loading Contribs::
@end menu

@node SLY Stickers
@section SLY Stickers

@SLY{} Stickers, in package @code{sly-stickers} is a live code
annotation tool. It's an alternative to the ``print'' or ``break''
statements you add to your code when debugging.

Contrary to these techniques, ``stickers'' are non-intrusive, meaning
that saving your file doesn't save your debug code along with it.

Here's the general workflow:

@itemize @bullet
@item
In Lisp source files, using @kbd{C-c C-s C-s} or @code{M-x
sly-stickers-dwim} places a sticker on any Lisp form. Stickers can
exist inside other stickers.

@*@image{images/stickers-1-placed-stickers,350pt}@*

@item
Stickers are ``armed'' when a definition or a file is compiled with the
familar @kbd{C-c C-c} (@code{M-x sly-compile-defun}) or @kbd{C-c C-k}
(@code{M-x sly-compile-file}) commands. An armed sticker changes color from
the default grey background to a blue background.

@*@image{images/stickers-2-armed-stickers,350pt}@*

@end itemize

From this point on, when the Lisp code is executed, the results of
evaluating the underlying forms are captured in the Lisp
side. Stickers help you examine your program's behaviour in three
ways:
@enumerate
@item
@kbd{C-c C-s C-r}
(or @code{M-x sly-stickers-replay}) interactively walks the user through
recordings in the order that they occured.

@*@image{images/stickers-3-replay-stickers,350pt}@*

@item
To step through stickers as your code is executed, ensure that
``breaking stickers'' are enabled via @code{M-x
sly-stickers-toggle-break-on-stickers}. Whenever a sticker-covered
expression is reached, the debugger comes up with useful restarts and
interactive for the values produced.

@*@image{images/stickers-4-breaking-stickers,350pt}@*

@item
@kbd{C-c C-s S} (@code{M-x sly-stickers-fetch}) populates the sticker
overlay with the latest captured results, called ``recordings''. If a sticker
has captured any recordings, it will turn green, otherwise it will turn
red. A sticker whose Lisp expression has caused a non-local exit, will
be also be marked with a special face.

@*@image{images/stickers-5-fetch-recordings,350pt}@*

@end enumerate

At any point, stickers can be removed with the
same @code{sly-stickers-dwim} keybinding, by placing the cursor at the
beginning of a sticker. Additionally adding prefix arguments
to @code{sly-stickers-dwim} increase its scope, so @kbd{C-u C-c C-s
C-s} will remove all stickers from the current function and @kbd{C-u
C-u C-c C-s C-s} will remove all stickers from the current file.

Stickers can be nested inside other stickers, so it is possible to
record the value of an expression inside another expression which is
also annotated.

Stickers are interactive parts just like any other part in @SLY{} that
represents Lisp-side objects, so they can be inspected and returned to
the REPL, for example. To move through the stickers with the keyboard
use the existing keybindings to move through compilatino
notes(@kbd{M-p} and @kbd{M-n}) or use @kbd{C-c C-s p} and @kbd{C-c C-s
n} (@code{sly-stickers-prev-sticker} and
@code{sly-stickers-next-sticker}).

There are some caveats when using @SLY{} Stickers:

@itemize
@item
Stickers on unevaluated forms (such as @code{let} variable bindings, or
other constructs) are rejected, though the function is still compiled as
usual. To let the user about this, these stickers remain grey, and are
marked as ``disarmed''. A message also appears in the echo area.
@item
Stickers placed on expressions inside backquoted expressions in macros
are always armed, even though they may come to provoke a runtime error
when the macro's expansion is run. Think of this when setting a sticker
inside a macro definition.
@end itemize

@node SLY Trace Dialog
@section SLY Trace Dialog

The @SLY{} Trace Dialog, in package @code{sly-trace-dialog}, is a
tracing facility, similar to Common Lisp's @code{trace}, but
interactive rather than purely textual. It is an Emacs 24-only
contrib.

You use it just like you would regular @code{trace}: after tracing a
function, calling it causes interesting information about that
particular call to be reported.

However, instead of printing the trace results to the
the @code{*trace-output*} stream (usually the REPL), the @SLY{}
Trace Dialog collects and stores them in your lisp environment until,
on user's request, they are fetched into Emacs and displayed in a
dialog-like interactive view.

After starting up @SLY{}, @SLY{}'s Trace Dialog installs
a @emph{Trace} menu in the menu-bar of any @code{sly-mode} buffer and
adds two new commands, with respective key-bindings:

@table @kbd
@kbditem{C-c M-t, sly-trace-dialog-toggle-trace}
If point is on a symbol name, toggle tracing of its function
definition. If point is not on a symbol, prompt user for a function.

With a @kbd{C-u} prefix argument, and if your lisp implementation
allows it, attempt to decipher lambdas, methods and other complicated
function signatures.

The function is traced for the @SLY{} Trace Dialog only, i.e. it is
not found in the list returned by Common Lisp's @code{trace}.

@kbditem{C-c T, sly-trace-dialog}
Pop to the interactive SLY Trace Dialog buffer associated with the
current connection (@pxref{Multiple connections}).
@end table

@page
Consider the (useless) program:

@example
(defun foo (n) (if (plusp n) (* n (bar (1- n))) 1))
(defun bar (n) (if (plusp n) (* n (foo (1- n))) 1))
@end example

After tracing both @code{foo} and @code{bar} with @kbd{C-c M-t},
calling call @code{(foo 2)} and moving to the trace dialog with
@kbd{C-c T}, we are presented with this buffer.

@example
Traced specs (2)                                  [refresh]
                                                  [untrace all]
  [untrace] common-lisp-user::bar
  [untrace] common-lisp-user::foo

Trace collection status (3/3)                     [refresh]
                                                  [clear]

   0 - common-lisp-user::foo
     | > 2
     | < 2
   1 `--- common-lisp-user::bar
        | > 1
        | < 1
   2    `-- common-lisp-user::foo
             > 0
             < 1
@end example

The dialog is divided into sections displaying the functions already
traced, the trace collection progress and the actual trace tree that
follow your program's logic. The most important key-bindings in this
buffer are:

@table @kbd
@kbditem{g, sly-trace-dialog-fetch-status}
Update information on the trace collection and traced specs.
@kbditem{G, sly-trace-dialog-fetch-traces}
Fetch the next batch of outstanding (not fetched yet) traces. With a
@kbd{C-u} prefix argument, repeat until no more outstanding traces.
@kbditem{C-k, sly-trace-dialog-clear-fetched-traces}
Prompt for confirmation, then clear all traces, both fetched and
outstanding.
@end table

The arguments and return values below each entry are interactive
buttons. Clicking them opens the inspector
(@pxref{Inspector}). Invoking @kbd{M-RET}
(@code{sly-trace-dialog-copy-down-to-repl}) returns them to the REPL
for manipulation (@pxref{REPL}). The number left of each entry
indicates its absolute position in the calling order, which might
differ from display order in case multiple threads call the same
traced function.

@code{sly-trace-dialog-hide-details-mode} hides arguments and return
values so you can concentrate on the calling logic. Additionally,
@code{sly-trace-dialog-autofollow-mode} will automatically
display additional detail about an entry when the cursor moves over
it.

@node TRAMP Support
@section TRAMP

@cindex TRAMP

The package @code{sly-tramp} provides some functions to set up
filename translations for TRAMP. (@pxref{Setting up pathname
translations})

@node Scratch Buffer
@section Scratch Buffer

@anchor{sly-scratch}
The @SLY{} scratch buffer, in contrib package @code{sly-scratch},
imitates Emacs' usual @code{*scratch*} buffer.
If @code{sly-scratch-file} is set, it is used to back the scratch
buffer, making it persistent. The buffer is like any other Lisp
buffer, except for the command bound to @kbd{C-j}.

@table @kbd

@kbditem{C-j, sly-eval-print-last-expression}
Evaluate the expression sexp before point and insert print value into
the current buffer.

@cmditem{sly-scratch}
Create a @file{*sly-scratch*} buffer. In this
buffer you can enter Lisp expressions and evaluate them with
@kbd{C-j}, like in Emacs's @file{*scratch*} buffer.

@end table

@node Loading Contribs
@section Loading Contrib Packages

@cindex Contribs
@cindex Contributions
@cindex Plugins

A special @code{sly-fancy} contrib package is loaded by default. You
might never want to fiddle with it, but if you find that you don't
like some package or you are having trouble with a package, you can
modify your setup a bit.  Generally, you set the
variable @code{sly-contribs} with the list of package-names that you
want to use.  For example, a setup to load only the @code{sly-scratch}
and @code{sly-mrepl} packages looks like:

@example
;; @emph{Setup load-path and autoloads}
(add-to-list 'load-path "~/dir/to/cloned/sly")
(require 'sly-autoloads)

;; @emph{Set your lisp system and some contribs}
(setq inferior-lisp-program "/opt/sbcl/bin/sbcl")
(setq sly-contribs '(sly-scratch sly-mrepl))
@end example

After starting @SLY{}, the commands of both packages should be
available.

@subsection Loading and unloading ``on the fly''

We recommend that you setup the @code{sly-contribs}
variable @emph{before} starting @SLY{} via @kbd{M-x sly}, but if you
want to enable more contribs @emph{after} you that, you can set
new @code{sly-contribs} variable to another value and call @code{M-x
sly-setup} or @code{M-x sly-enable-contrib}. Note this though:

@itemize @bullet
@item
If you've removed contribs from the list they won't be unloaded
automatically.
@item
If you have more than one @SLY{} connection currently active, you must
manually repeat the @code{sly-setup} step for each of them.
@end itemize

Short of restarting Emacs, a reasonable way of unloading contribs is
by calling an Emacs Lisp function whose name is obtained by
adding @code{-unload} to the contrib's name, for every contrib you
wish to unload. So, to remove @code{sly-mrepl}, you must call
@code{sly-mrepl-unload}. Because the unload function will only, if
ever, unload the Emacs Lisp side of the contrib, you may also need to
restart your lisps.

@node Credits
@chapter Credits

@emph{The soppy ending...}

@unnumberedsec Hackers of the good hack

@SLY{} is a fork of SLIME which is itself an Extension
of @acronym{SLIM} by Eric Marsden. At the time of writing, the authors
and code-contributors of @SLY{} are:

@include contributors.texi

... not counting the bundled code from @file{hyperspec.el},
@cite{CLOCC}, and the @cite{CMU AI Repository}.

Many people on the @code{sly-devel} mailing list have made non-code
contributions to @SLY{}. Life is hard though: you gotta send code to
get your name in the manual. @code{:-)}

@unnumberedsec Thanks!

We're indebted to the good people of @code{common-lisp.net} for their
hosting and help, and for rescuing us from ``Sourceforge hell.''

Implementors of the Lisps that we support have been a great help. We'd
like to thank the @acronym{CMUCL} maintainers for their helpful
answers, Craig Norvell and Kevin Layer at Franz providing Allegro CL
licenses for @SLY{} development, and Peter Graves for his help to
get @SLY{} running with @acronym{ABCL}.

Most of all we're happy to be working with the Lisp implementors
who've joined in the @SLY{} development: Dan Barlow and Christophe
Rhodes of @acronym{SBCL}, Gary Byers of OpenMCL, and Martin Simmons of
LispWorks. Thanks also to Alain Picard and Memetrics for funding
Martin's initial work on the LispWorks backend!

@node Key Index 
@unnumbered Key (Character) Index
@printindex ky

@node Command Index
@unnumbered Command and Function Index
@printindex fn

@node Variable Index
@unnumbered Variable and Concept Index
@printindex vr

@bye
Local Variables:
paragraph-start: "@[a-zA-Z]+\\({[^}]+}\\)?[ \n]\\|[ ]*$"
paragraph-separate: "@[a-zA-Z]+\\({[^}]+}\\)?[ \n]\\|[ ]*$"
End:
