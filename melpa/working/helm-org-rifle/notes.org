* Contents :TOC:
 - [[#code][Code]]
     - [[#profiling][Profiling]]
     - [[#context-splitting][Context-splitting]]
 - [[#plans][Plans]]
     - [[#search-files-instead-of-buffers][Search files instead of buffers]]
     - [[#match-tags-separately][Match tags separately]]
     - [[#case-sensitive-if-caps-are-present][Case-sensitive if caps are present]]
     - [[#substring-matching][Substring matching]]
     - [[#maybe-use-grep-to-find-matching-lines][MAYBE Use grep to find matching lines]]
     - [[#maybe-flx-sorting][MAYBE flx sorting]]
     - [[#maybe-match-only-headings][MAYBE Match only headings]]
     - [[#maybe-testing-with-buttercup][MAYBE Testing with Buttercup]]
     - [[#support-new-helm-with-input-idle-delay][Support new Helm with input-idle-delay]]
 - [[#bugs][Bugs]]
     - [[#c-negation-only-error][[#C] Negation-only error]]
     - [[#b-helm-org-rifle-tags-matching][[#B] helm-org-rifle tags matching]]
 - [[#checklists][Checklists]]
     - [[#stable-release-120][Stable release 1.2.0]]
     - [[#stable-release-11][Stable release 1.1]]
     - [[#stable-release-template][Stable release template]]

* Code

These come in handy while coding.

** Profiling

Why aren't macros like these in some default package?  Sure beats having to type ~(mapcar (lambda (it) (...it...)) list)~ over and over.

#+BEGIN_SRC elisp
  (defmacro it (&rest body)
    `(lambda (it)
       ,@body))
  (defmacro mapit (seq &rest body)
    `(mapcar (lambda (it)
               ,@body)
             ,seq))
#+END_SRC

This makes it easy to profile code:

#+BEGIN_SRC elisp
  (defmacro profile-rifle (times &rest body)
    `(let (output)
       (dolist (p '("helm-" "org-" "string-" "s-" "buffer-" "append" "delq" "map" "list" "car" "save-" "outline-" "delete-dups" "sort" "line-" "nth" "concat" "char-to-string" "rx-" "goto-" "when" "search-" "re-"))
         (elp-instrument-package p))
       (dotimes (x ,times)
         ,@body)
       (elp-results)
       (elp-restore-all)
       (point-min)
       (forward-line 20)
       (delete-region (point) (point-max))
       (setq output (buffer-substring-no-properties (point-min) (point-max)))
       (kill-buffer)
       (delete-window)
       output))
#+END_SRC

#+RESULTS:
: profile-rifle

** Context-splitting

Prototype code, keeping for future reference.

#+BEGIN_SRC elisp
(let* ((num-context-words 2)
       (needle "needle")
       (haystack "one two three needle four five six")
       (hay (s-split needle haystack))
       (left-hay (s-split-words (car hay)))
       (right-hay (s-split-words (nth 1 hay))))
  (concat "..."
          (s-join " " (subseq left-hay (- num-context-words)))
          " " needle " "
          (s-join " " (subseq right-hay 0 num-context-words))
          "..."))

;; Multiple needles
(let* ( (needles '("needle" "pin"))
        (haystack "one two three \" needle not pin four five six seven eight pin nine ten eleven twelve"))
  (cl-loop for needle in needles
           append (cl-loop for re = (rx-to-string `(and (repeat 1 ,helm-org-rifle-context-words (and (1+ (not space))
                                                                                                     (or (1+ space)
                                                                                                         word-boundary)))
                                                        (group (eval needle))
                                                        (repeat 1 ,helm-org-rifle-context-words (and (or word-boundary
                                                                                                         (1+ space))
                                                                                                     (1+ (not space))))))
                           for m = (string-match re haystack end)
                           for end = (match-end 1)
                           while m
                           collect (concat "..." (match-string-no-properties 0 haystack) "..."))))
#+END_SRC

*** Slow code that splits on word boundaries

This code splits on word boundaries, but it's very slow.  Profiling it
showed the vast majority of the time was in =string-match=.  I'm
guessing the regexp is too complicated or unoptimized.

#+BEGIN_SRC elisp
  ;; Reduce matching lines to matched word with context
  (setq matched-words-with-context
        (cl-loop for line in (map 'list 'car matching-lines-in-node)
                 append (cl-loop for token in input
                                 for re = (rx-to-string
                                           `(and (repeat 0 ,helm-org-rifle-context-words
                                                         (and (1+ (not space))
                                                              (or (1+ space)
                                                                  word-boundary)))
                                                 (group (eval token))
                                                 (repeat 0 ,helm-org-rifle-context-words
                                                         (and (or word-boundary
                                                                  (1+ space))
                                                              (1+ (not space))))))
  
                                 ;;  This one line uses about 95% of the runtime of this function
                                 for m = (string-match re line end)
  
                                 for end = (match-end 1)
                                 when m
                                 collect (match-string-no-properties 0 line))))
#+END_SRC

*** Faster version that cuts off mid-word

This version is much, much faster, but instead of matching on word
boundaries, it just matches so-many characters before and after the
token.  It's not quite as nice, but the speedup is worth it, and it
seems good enough.

This is the version currently in-use.

#+BEGIN_SRC elisp
(setq matched-words-with-context
                    (cl-loop for line in (map 'list 'car matching-lines-in-node)
                             append (cl-loop for token in input
                                             for re = (rx-to-string '(and (repeat 0 25 not-newline)
                                                                          (eval token)
                                                                          (repeat 0 25 not-newline)))
                                             for m = (string-match re line end)

                                             for end = (match-end 1)
                                             when m
                                             collect (match-string-no-properties 0 line))))
#+END_SRC

*** DONE Fix it
CLOSED: [2016-04-01 Fri 22:55]
:LOGBOOK:
- State "DONE"       from "TODO"       [2016-04-01 Fri 22:55] \\
  Okay, it works now.  Here's hoping I don't break it again.
- State "TODO"       from "TODO"       [2016-04-01 Fri 19:03]
:END:

[2016-04-01 Fri 19:03] Somehow I broke it.  Now to fix it...

I don't understand why this loop isn't working like I want it to:

#+BEGIN_SRC elisp
  (cl-loop with end
           for line in (mapcar 'car matching-lines-in-node)
           for token in input
           for re = (rx-to-string `(and (repeat 0 ,helm-org-rifle-context-characters not-newline)
                                        (eval token)
                                        (repeat 0 ,helm-org-rifle-context-characters not-newline)))
           for match = (string-match re line end)
           for end = (match-end 0)
           when match
           collect (match-string-no-properties 0 line))
#+END_SRC

From what I can tell from the manual, it should do what I want.  Let's try this:

#+BEGIN_SRC elisp
  (cl-loop for line in '("1" "2" "3")
           for word in '("a" "b" "c")
           collect (list (format "Line:%s Word:%s" line word)))
#+END_SRC

#+RESULTS:
| Line:1 Word:a |
| Line:2 Word:b |
| Line:3 Word:c |

Well that does /not/ behave like Python list-comps.  So let's try nested:

#+BEGIN_SRC elisp
  (cl-loop for line in '("1" "2" "3")
           collect (cl-loop for word in '("a" "b" "c")
                            collect (format "Line:%s Word:%s" line word)))
#+END_SRC

#+RESULTS:
| Line:1 Word:a | Line:1 Word:b | Line:1 Word:c |
| Line:2 Word:a | Line:2 Word:b | Line:2 Word:c |
| Line:3 Word:a | Line:3 Word:b | Line:3 Word:c |

There.  So this loop should work:

#+BEGIN_SRC elisp
  (cl-loop with end
           for line in (mapcar 'car matching-lines-in-node)
for end = nil
           collect (cl-loop for token in input
                            for re = (rx-to-string `(and (repeat 0 ,helm-org-rifle-context-characters not-newline)
                                                         (eval token)
                                                         (repeat 0 ,helm-org-rifle-context-characters not-newline)))
                            for match = (string-match re line end)
                            for end = (match-end 0)
                            when match
                            collect (match-string-no-properties 0 line)))
#+END_SRC

#+BEGIN_SRC elisp
(helm-org-rifle-get-candidates-in-buffer (get-file-buffer "~/org/inbox.org") "emacs :org:")
#+END_SRC

Hm...not quite.  Well, this is the code from just before the commit that broke it:

#+BEGIN_SRC elisp
  (setq matched-words-with-context
        (cl-loop for line in (map 'list 'car matching-lines-in-node)
                 append (cl-loop with end
                                 for token in input
                                 for re = (rx-to-string `(and (repeat 0 ,helm-org-rifle-context-characters not-newline)
                                                              (eval token)
                                                              (repeat 0 ,helm-org-rifle-context-characters not-newline)))
                                 for match = (string-match re line end)
                                 if match
                                 do (setq end (match-end 0))
                                 and collect (match-string-no-properties 0 line)
  
#+END_SRC

**** Profile with fix

#+BEGIN_SRC elisp 
(profile-rifle 10 (helm-org-rifle-get-candidates-in-buffer (find-file-noselect "~/org/inbox.org") "emacs helm !mail"))
#+END_SRC

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       10          5.8943273229  0.5894327322
search-forward-regexp                                         8600        0.6587784959  7.660...e-05
org-heading-components                                        1950        0.4991581810  0.0002559785
s-matches?                                                    12470       0.2917804840  2.339...e-05
mapconcat                                                     3960        0.2702167040  6.823...e-05
helm-org-rifle-fontify-like-in-org-mode                       190         0.2635406889  0.0013870562
goto-char                                                     8610        0.2543786740  2.954...e-05
rx-form                                                       9980        0.2420250770  2.425...e-05
org-back-to-heading                                           1950        0.2031512759  0.0001041801
outline-back-to-heading                                       1950        0.1968846809  0.0001009665
s-join                                                        2520        0.1756191310  6.969...e-05
string-match                                                  15810       0.1671791649  1.057...e-05
org-do-latex-and-related                                      190         0.1668239079  0.0008780205
org-string-nw-p                                               190         0.1662417530  0.0008749565
outline-next-heading                                          1960        0.1556081469  7.939...e-05
line-beginning-position                                       9630        0.1470939420  1.527...e-05
line-end-position                                             4720        0.1437326400  3.045...e-05
rx-to-string                                                  1430        0.1409834220  9.858...e-05
rx-and                                                        1430        0.1234839939  8.635...e-05
outline-previous-heading                                      1950        0.0872664470  4.475...e-05
#+end_example

Hm, that seems nearly twice as slow as before, compared to [[id:413c432f-6c8a-4f41-bbd4-486d859fe571][this]].  Let's try without negation:

#+BEGIN_SRC elisp 
(profile-rifle 10 (helm-org-rifle-get-candidates-in-buffer (find-file-noselect "~/org/inbox.org") "emacs helm"))
#+END_SRC

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       10          6.000442529   0.6000442529
rx-form                                                       9940        0.7762075249  7.808...e-05
search-forward-regexp                                         6740        0.6341296550  9.408...e-05
org-heading-components                                        1950        0.5162909810  0.0002647646
rx-to-string                                                  1420        0.4960243830  0.0003493129
rx-and                                                        1420        0.3026813919  0.0002131559
mapconcat                                                     3950        0.2855619800  7.229...e-05
goto-char                                                     8700        0.2558434080  2.940...e-05
org-back-to-heading                                           1950        0.2032723169  0.0001042422
outline-back-to-heading                                       1950        0.1968941550  0.0001009713
car                                                           27602       0.1839865229  6.665...e-06
string-match                                                  15930       0.1689102720  1.060...e-05
outline-next-heading                                          1960        0.1560765069  7.963...e-05
line-beginning-position                                       9770        0.1480645649  1.515...e-05
line-end-position                                             4790        0.1447068689  3.021...e-05
s-matches?                                                    12640       0.1309880819  1.036...e-05
helm-org-rifle-fontify-like-in-org-mode                       190         0.1011150069  0.0005321842
outline-previous-heading                                      1950        0.0869701169  4.460...e-05
rx-repeat                                                     2840        0.0425908090  1.499...e-05
buffer-substring-no-properties                                8940        0.0324401760  3.628...e-06
#+end_example

Okay, that's bad.  But something is obviously wrong, because it's calling =rx-form= and =search-forward-regexp= way too many times.  Let's see...

The problem is that the =positive-re= is matching anywhere, not just at word boundaries, so it's matching way too many nodes.  Well, that is /a/ problem; I don't know if it explains the entire slowdown.

For example, this matches =overwhelming= because of the =helm= in the middle:

#+BEGIN_SRC elisp
"\\(\\(?:[ 	]+\\(:[[:alnum:]_@#%%:]+:\\)\\)?\\| \\)emacs\\(\\(?:[ 	]+\\(:[[:alnum:]_@#%%:]+:\\)\\)?\\| \\|$\\)\\|\\(\\(?:[ 	]+\\(:[[:alnum:]_@#%%:]+:\\)\\)?\\| \\)helm\\(\\(?:[ 	]+\\(:[[:alnum:]_@#%%:]+:\\)\\)?\\| \\|$\\)"
#+END_SRC

Okay, the problem now is that I changed =helm-org-rifle-tags-re= to fix tag matching, but that same regexp is used in =helm-org-rifle-prep-token=, and now that function is matching any token as a tag and giving the wrong result.

I do not understand /why/ it's doing that, because that regexp is only supposed to match /tags/...

Okay, the other regexp that I kept commented out appears to match actual tags, as in it's useful for testing whether a string /is/ a tag:

#+BEGIN_SRC elisp
(org-re ":\\([[:alnum:]_@#%:]+\\):[ \t]*$")
#+END_SRC

While this one appears to match tags in a document, potentially in a list of tags:

#+BEGIN_SRC elisp
(org-re "\\(?:[ \t]+\\(:[[:alnum:]_@#%%:]+:\\)\\)?")
#+END_SRC

Okay, I fixed it, I had an =if match= instead of a =while match= in the =matched-words-with-context= loop.

Now to profile and compare with the pre-fix-context version:

*Pre-context-fixed version:* master @ 5c30f38

#+NAME: context-fixed-test
#+BEGIN_SRC elisp :results value
  (profile-rifle 50 (helm-org-rifle-get-candidates-in-buffer (find-file-noselect "~/org/inbox.org") "emacs helm"))
#+END_SRC

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       50          17.799054759  0.3559810951
org-heading-components                                        9350        2.6933843979  0.0002880625
helm-org-rifle-fontify-like-in-org-mode                       950         1.7538910299  0.0018462010
org-back-to-heading                                           11250       1.3298633500  0.0001182100
outline-back-to-heading                                       11250       1.1494924389  0.0001021771
goto-char                                                     37300       1.0525728939  2.821...e-05
search-forward-regexp                                         18600       0.9430047979  5.069...e-05
outline-next-heading                                          11300       0.7735385280  6.845...e-05
s-contains?                                                   50600       0.7211126610  1.425...e-05
rx-form                                                       1400        0.4769376879  0.0003406697
outline-previous-heading                                      9350        0.4475351999  4.786...e-05
line-beginning-position                                       20450       0.3628916579  1.774...e-05
line-end-position                                             10250       0.3234668489  3.155...e-05
list                                                          36850       0.3109050100  8.437...e-06
org-indent-refresh-maybe                                      1900        0.3052489690  0.0001606573
helm-org-rifle-prep-token                                     18700       0.3021837809  1.615...e-05
string-match                                                  71250       0.2578011050  3.618...e-06
buffer-substring-no-properties                                29350       0.2555603400  8.707...e-06
org-indent-add-properties                                     1900        0.2475959590  0.0001303136
org-at-heading-p                                              11200       0.2333956789  2.083...e-05
#+end_example

*Context-fixed version:* 2b5b12a

#+CALL: context-fixed-test[]()

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       50          28.748935016  0.5749787003
search-forward-regexp                                         33700       3.2623649319  9.680...e-05
org-heading-components                                        9750        2.4923882399  0.0002556295
helm-org-rifle-fontify-like-in-org-mode                       950         1.9004250499  0.0020004474
goto-char                                                     43500       1.5172595929  3.487...e-05
s-matches?                                                    63200       1.3970165480  2.210...e-05
org-back-to-heading                                           11650       1.3835048189  0.0001187557
outline-back-to-heading                                       11650       1.3488680939  0.0001157826
outline-next-heading                                          11700       0.8288543339  7.084...e-05
line-beginning-position                                       48850       0.7972754510  1.632...e-05
line-end-position                                             24900       0.7767868229  3.119...e-05
string-match                                                  83750       0.6722922219  8.027...e-06
mapcar                                                        10778       0.5059252250  4.694...e-05
outline-previous-heading                                      9750        0.4670275909  4.790...e-05
org-at-heading-p                                              25850       0.4494715110  1.738...e-05
car                                                           130862      0.3298968730  2.520...e-06
org-indent-refresh-maybe                                      1900        0.3058012260  0.0001609480
org-indent-add-properties                                     1900        0.2488298529  0.0001309630
outline-on-heading-p                                          37500       0.2456449769  6.550...e-06
s-trim                                                        5050        0.2146568449  4.250...e-05
#+end_example

[2016-04-02 Sat 00:14] Well, that's definitely worse, although it's still probably fast enough, because the elp instrumentation makes it a lot slower.

I'm also noticing that when I eval the buffer of the old version, and then the new one, and back and forth, it's giving different results than when I start a new Emacs session before eval'ing each buffer.  The content-fixed version is still slower, but it's annoying that they are somehow interfering with each other...

Oh, I know what it probably is: =defvar= not changing already-defined vars.  Gah, I wish there were a "developer mode" that would automatically treat =defvar= as =setq=!  That might also be causing different results to be returned.

And on that note, notice that the old version is running =org-heading-components= 9350 times and the new one 9750 times (divided by 50 runs, of course).  That means the newer one is returning more results.  That's /probably/ a good thing--better than returning fewer results--but it's still an annoying discrepancy.

Well, anyway, it seems that the new version is working properly, even if it is a bit slower.  I can probably optimize it some from here by profiling it some more.  And it's probably still fast enough anyway.  I'm going to commit these test results and go from there.

[2016-04-02 Sat 00:24] I just noticed that the new version has =search-forward-regexp= while the old shows =re-search-forward=.  I guess I accidentally used one instead of the other.  And I didn't have =re-= in the =profile-rifle= macro, so it wasn't being instrumented.  But I can't even find out what the difference between those two functions is.  Their docstrings are identical, but =re-search-forward= says it's "an interactive built-in function in `C source code'" and =search-forward-regexp= says it's an "interactive built-in function".  If one were an alias for the other, wouldn't it say so, like other functions do?  And I just googled it, and I can't even find any discussions disambiguating them.

Well, I guess I will change all the =search-forward-regexp= to =re-search-forward= and profile it again, now with =re-= instrumented...

#+CALL: context-fixed-test[]()

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       50          29.720079127  0.5944015825
re-search-forward                                             95750       10.653707145  0.0001112658
helm-org-rifle-fontify-like-in-org-mode                       950         3.115803256   0.0032797929
org-heading-components                                        9750        2.0726401679  0.0002125784
goto-char                                                     43500       1.5346791419  3.527...e-05
s-matches?                                                    63200       1.3961592560  2.209...e-05
org-back-to-heading                                           11650       1.2585600799  0.0001080309
outline-back-to-heading                                       11650       1.2252464660  0.0001051713
outline-next-heading                                          11700       1.0289735719  8.794...e-05
string-match                                                  83850       0.9593000099  1.144...e-05
outline-previous-heading                                      9750        0.8035638840  8.241...e-05
line-beginning-position                                       48850       0.8014680960  1.640...e-05
line-end-position                                             24900       0.7814555490  3.138...e-05
re-search-backward                                            13950       0.6276933279  4.499...e-05
buffer-substring-no-properties                                44700       0.4611391599  1.031...e-05
s-trim                                                        5050        0.3644793139  7.217...e-05
mapcar                                                        10780       0.3609109789  3.347...e-05
org-indent-refresh-maybe                                      1900        0.3286191740  0.0001729574
org-unfontify-region                                          950         0.3180826990  0.0003348238
org-at-heading-p                                              25850       0.3019532499  1.168...e-05
#+end_example

Well, that made it a bit slower... and =re-search-forward= is running 1915 times per run, which seems like a lot.  Well, just for fun, let's see if =search-forward-regexp= is any different...

#+CALL: context-fixed-test[]()

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       50          29.894388876  0.5978877775
search-forward-regexp                                         43500       9.9810062590  0.0002294484
helm-org-rifle-fontify-like-in-org-mode                       950         2.8640568999  0.0030147967
org-heading-components                                        9750        2.5292111220  0.0002594062
s-matches?                                                    63200       1.5561717319  2.462...e-05
goto-char                                                     43500       1.5376464950  3.534...e-05
org-back-to-heading                                           11650       1.2684373279  0.0001088787
outline-back-to-heading                                       11650       1.2354534740  0.0001060475
string-match                                                  83850       0.9752567150  1.163...e-05
outline-next-heading                                          11700       0.8854215550  7.567...e-05
line-beginning-position                                       48850       0.8027929070  1.643...e-05
line-end-position                                             24900       0.7844873019  3.150...e-05
re-search-backward                                            13950       0.7822806550  5.607...e-05
re-search-forward                                             52250       0.7321030019  1.401...e-05
outline-previous-heading                                      9750        0.6612776079  6.782...e-05
buffer-substring-no-properties                                44700       0.6150929480  1.376...e-05
org-indent-refresh-maybe                                      1900        0.4929963640  0.0002594717
org-indent-add-properties                                     1900        0.4216444500  0.0002219181
mapcar                                                        10780       0.3625142850  3.362...e-05
s-join                                                        12650       0.3601353390  2.846...e-05
#+end_example

Well, seems about the same.  Some other functions are calling =re-search-forward=.  I guess I'll stick to =re-search-forward= for consistency.

Let's see if I can optimize this regexp, because it's the one used for finding the next matching node:

#+BEGIN_SRC elisp
(positive-re (mapconcat 'helm-org-rifle-prep-token input "\\|"))
#+END_SRC

Wait...I think I can't do that, because each token has to be handled separately in case it's a tag.  At least, that's the way I found that works.

I just realized something: because =re-= wasn't instrumented when I profiled the pre-context-fix code, that probably made the test runs a lot faster.  I should rerun that test now that I've instrumented =re-=:

#+CALL: context-fixed-test[]()

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       50          18.989564333  0.3797912866
re-search-forward                                             61250       3.4628969270  5.653...e-05
org-heading-components                                        9350        2.690181023   0.0002877198
helm-org-rifle-fontify-like-in-org-mode                       950         1.8528630730  0.0019503821
goto-char                                                     37300       1.3264769309  3.556...e-05
org-back-to-heading                                           11250       1.3099172920  0.0001164370
outline-back-to-heading                                       11250       1.2793007219  0.0001137156
search-forward-regexp                                         18600       0.9837737700  5.289...e-05
s-contains?                                                   50600       0.9775941719  1.932...e-05
outline-next-heading                                          11300       0.8469392419  7.495...e-05
re-search-backward                                            13400       0.6245546379  4.660...e-05
outline-previous-heading                                      9350        0.4990147979  5.337...e-05
org-indent-refresh-maybe                                      1900        0.4647722440  0.0002446169
line-beginning-position                                       20450       0.4323783559  2.114...e-05
line-end-position                                             10250       0.3633604599  3.544...e-05
helm-org-rifle-prep-token                                     18700       0.3031164060  1.620...e-05
org-indent-add-properties                                     1900        0.2517753239  0.0001325133
buffer-substring-no-properties                                29350       0.247449885   8.431...e-06
org-at-heading-p                                              11200       0.2308021850  2.060...e-05
s-join                                                        12200       0.2029973209  1.663...e-05
#+end_example

Uh...that's a lot slower...even slower than the context-fixed version.  And it's running =re-search-forward= about 1/3rd fewer times, yet it's still slower.  That means the context-fixed version is faster...yet it doesn't /feel/ faster...  This is getting really confusing.

...Or not!  I ran it again, and this time it was back to 0.38 seconds per run, instead of the 0.88 that it showed.  So the old version /is/ faster.  Argh, I even restarted Emacs between runs, but the results are still not always consistent.

(Haha, if anyone reads this on GitHub, they're going to be confused, because GitHub doesn't display results blocks in their Org renderer.)

Back to testing the context-fixed version:

#+CALL: context-fixed-test[]()

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       50          30.890125471  0.6178025094
re-search-forward                                             95750       10.759003013  0.0001123655
org-heading-components                                        9750        3.0528847219  0.0003131163
s-matches?                                                    63200       1.9809823760  3.134...e-05
goto-char                                                     43500       1.5808144250  3.634...e-05
org-back-to-heading                                           11650       1.3265871900  0.0001138701
outline-back-to-heading                                       11650       1.2950595060  0.0001111639
outline-next-heading                                          11700       1.0353336260  8.849...e-05
line-beginning-position                                       48850       1.0339746409  2.116...e-05
line-end-position                                             24900       1.0186344770  4.090...e-05
outline-previous-heading                                      9750        0.8171171010  8.380...e-05
helm-org-rifle-fontify-like-in-org-mode                       950         0.8004842739  0.0008426150
string-match                                                  83850       0.6619865150  7.894...e-06
re-search-backward                                            13950       0.6425335970  4.605...e-05
buffer-substring-no-properties                                44700       0.4572488249  1.022...e-05
car                                                           130863      0.3309231389  2.528...e-06
s--truthy?                                                    63200       0.3191290470  5.049...e-06
list                                                          65650       0.1679614680  2.558...e-06
org-indent-refresh-maybe                                      1900        0.1644345459  8.654...e-05
delete-dups                                                   9750        0.1581602390  1.622...e-05
#+end_example

Maybe the problem is [[file:helm-org-rifle.el::thereis%20(s-matches?%20re%20target)))][here]]:

#+BEGIN_SRC elisp
(s-matches? re target)
#+END_SRC

In the pre-context-fix version, I'm using:

#+BEGIN_SRC elisp
(s-contains? token target t)
#+END_SRC

I think I changed to the regexp version because the =s-contains?= version was doing substring matching, which I don't want.  Let's switch it real quick just to see if that's the problem:

#+CALL: context-fixed-test[]()

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       50          29.681379652  0.5936275930
re-search-forward                                             78050       10.705968030  0.0001371680
org-heading-components                                        9750        2.3193180259  0.0002378787
goto-char                                                     43500       1.5864029119  3.646...e-05
org-back-to-heading                                           10850       1.1765637859  0.0001084390
outline-back-to-heading                                       10850       1.1455293570  0.0001055787
helm-org-rifle-fontify-like-in-org-mode                       550         1.1138197010  0.0020251267
line-beginning-position                                       48450       1.0433171030  2.153...e-05
outline-next-heading                                          10900       1.0355597489  9.500...e-05
line-end-position                                             24500       1.0200701619  4.163...e-05
s-contains?                                                   58300       0.8684338029  1.489...e-05
s-join                                                        11450       0.6645958719  5.804...e-05
outline-previous-heading                                      9750        0.6607329249  6.776...e-05
re-search-backward                                            13550       0.6436711090  4.750...e-05
mapconcat                                                     11550       0.6339636089  5.488...e-05
buffer-substring-no-properties                                44600       0.4622889649  1.036...e-05
mapcar                                                        10380       0.3559940170  3.429...e-05
car                                                           121013      0.3262029620  2.695...e-06
string-match                                                  73550       0.3073863820  4.179...e-06
org-at-heading-p                                              25050       0.2945103339  1.175...e-05
#+end_example

Eh, it's only about 20ms faster per run, although =s-contains?= is more than twice as fast as =s-matches?=.  But it's still such a short time that it doesn't make much difference.

This is probably where the =next-gen= branch would be easier to optimize.  Even if all the extra function calls took their toll, at least I could profile each one separately.  With this, I see all those =re-search-forward= calls listed, but it's hard to figure out why that's making it slower than the pre-context-fix version.

Okay, I think I see what the problem is, or almost:

Pre-context-fix: =re-search-forward 61250 3.4628969270 5.653...e-05=
Post-context-fix: =re-search-forward 78050 10.705968030 0.0001371680=

The time per call to this function in the old version is much shorter, so the problem must be the regexp complexity.  And that is a bit annoying, because I thought I was being careful to make it simpler, like by wrapping the whole regexp in the word-boundary matcher instead of each token in the =or= group.

It's almost surely this one: ~(re-search-forward positive-re node-end t)~, because the other two are the negation one (which isn't being called in this test), and the per-node matcher ~(re-search-forward positive-re nil t)~, which is only run once per partially-matching node, in the main loop, while the other one runs multiple times per partially-matching node.  They both use the same regexp though.  Maybe if I can optimize the regexp used in that one...

I'm not sure that I can, though, because IIRC I had to do it this way to avoid substring matching:

#+BEGIN_SRC elisp
  (positive-re (mapconcat 'helm-org-rifle-prep-token input "\\|"))
#+END_SRC

Maybe having each token wrapped with =helm-org-rifle-prep-token= is the problem, but I think if I change that, I'll get substring matching, which I don't want.  Also there's [[*Weird%20heading-only,%20second-word%20substring%20matching][this]]: while before I /thought/ I wasn't getting substring matching, it might be that I actually was, but only for tokens after the first.

Sigh.  I can see how having a testing framework for this would help a lot...

Well, I'm going to try a quick experiment: the faster version has this:

#+BEGIN_SRC elisp
  (setq matching-positions-in-node
        (or (cl-loop for token in all-tokens
                     do (goto-char node-beg)
                     while (re-search-forward (helm-org-rifle-prep-token token) node-end t)
                     when negations
                     when (cl-loop for negation in negations
                                   thereis (s-matches? negation
                                                       (buffer-substring-no-properties (line-beginning-position)
                                                                                       (line-end-position))))
                     return nil
                     collect (line-beginning-position) into result
                     do (end-of-line)
                     finally return (sort (delete-dups result) '<))
            ;; Negation found; skip node
            (throw 'negated (goto-char node-end))))
#+END_SRC

And the slower version has this:

#+BEGIN_SRC elisp
  (when (and negations
             (re-search-forward negations-re node-end t))
    (throw 'negated (goto-char node-end)))
  
  (setq matching-positions-in-node
        (cl-loop initially (goto-char node-beg)
                 while (re-search-forward positive-re node-end t)
                 collect (line-beginning-position) into result
                 do (end-of-line)
                 finally return (sort (delete-dups result) '<)))
#+END_SRC

It's hard for me to imagine how the first one is faster, even without negations, because it should be running more searches, about one for each token times the number of matching lines, rather than one for the number of matching lines.  And =helm-org-rifle-prep-token= is being called...well it should be a /lot/ of times, once per token per node, at least, so that /should/ be much slower! But maybe the more complex regexp is /that/ much slower, so that running more, simpler searches is faster.  Let's find out... one, ta-hoo-hoo, tha-ree...

#+BEGIN_SRC elisp
  (setq matching-positions-in-node
        (cl-loop for token in input
                 do (goto-char node-beg)
                 while (re-search-forward (helm-org-rifle-prep-token token) node-end t)
                 collect (line-beginning-position) into result
                 do (end-of-line)
                 finally return (sort (delete-dups result) '<)))
#+END_SRC

#+CALL: context-fixed-test[]()

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       50          30.736917460  0.6147383492
re-search-forward                                             110600      12.773894478  0.0001154963
org-heading-components                                        9750        2.4618781539  0.0002525003
helm-org-rifle-fontify-like-in-org-mode                       850         1.8120636949  0.0021318396
line-beginning-position                                       35200       1.5948968589  4.530...e-05
goto-char                                                     38750       1.5266306220  3.939...e-05
org-back-to-heading                                           11450       1.4955711799  0.0001306175
outline-back-to-heading                                       11450       1.4644250010  0.0001278973
outline-next-heading                                          11500       1.1824791589  0.0001028242
helm-org-rifle-prep-token                                     19400       1.0364527230  5.342...e-05
s-matches?                                                    39950       0.9029048190  2.260...e-05
outline-previous-heading                                      9750        0.8225591450  8.436...e-05
re-search-backward                                            13850       0.6591115870  4.758...e-05
org-indent-refresh-maybe                                      1700        0.4569549119  0.0002687970
concat                                                        59950       0.3421275590  5.706...e-06
org-indent-add-properties                                     1700        0.2434831740  0.0001432253
org-indent-notify-modified-headline                           1700        0.1823105449  0.0001072414
mapconcat                                                     12450       0.1753660190  1.408...e-05
car                                                           75363       0.1692585069  2.245...e-06
list                                                          58150       0.1671702790  2.874...e-06
#+end_example

Well, that's basically the same.  Even though =helm-org-rifle-prep-token= is being called 19,400 times now (whereas before it wasn't even on the chart), the overall run is about the same speed.  And =re-search-forward= is being called 110,600 times instead of 78,050 times, and that's adding two seconds to the overall time, yet the overall time is only 1 second slower, and each run is only 0.02 seconds slower.

I really don't know.  It's probably still acceptably fast, but I'm not happy that it's 240 ms slower per run than it was before.

Wait...is it the context matching that's slowing it down?  That would seem to make sense, but I don't see =string-match= or =match-string-no-properties= on the chart, which are called a lot in the context-getting part.  Again, this is where the =next-gen= branch would be easier to profile, because that part would be in a separate function, which would show up on the benchmark.

Okay, so let's try disabling the context-matching and see if that helps narrow it down.

#+CALL: context-fixed-test[]()

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       50          30.781087232  0.6156217446
re-search-forward                                             110600      12.989410668  0.0001174449
org-heading-components                                        9750        2.0101349390  0.0002061676
helm-org-rifle-fontify-like-in-org-mode                       850         2.0032276699  0.0023567384
line-beginning-position                                       35200       1.6018393130  4.550...e-05
goto-char                                                     38750       1.5316418570  3.952...e-05
org-back-to-heading                                           11450       1.1903071840  0.0001039569
outline-back-to-heading                                       11450       1.1586320740  0.0001011905
s-matches?                                                    39950       1.0665855099  2.669...e-05
helm-org-rifle-prep-token                                     19400       1.0471090219  5.397...e-05
outline-next-heading                                          11500       0.8812347759  7.662...e-05
outline-previous-heading                                      9750        0.6750363980  6.923...e-05
re-search-backward                                            13850       0.6601655850  4.766...e-05
s-join                                                        12350       0.5171406150  4.187...e-05
org-activate-plain-links                                      1200        0.3440198649  0.0002866832
mapconcat                                                     12450       0.3296189910  2.647...e-05
list                                                          58150       0.3267329869  5.618...e-06
org-indent-refresh-maybe                                      1700        0.3121118990  0.0001835952
string-match                                                  61000       0.2487342409  4.077...e-06
buffer-substring-no-properties                                20750       0.2216961110  1.068...e-05
#+end_example

Wow...nope.  I set the context matches to a hardcoded string, and it actually took longer.  That makes noooooo sense.  I guess the context matching isn't the problem.

Ok then, let's see if avoiding substring matches is really the problem.  Let's change that back so that it does match substrings and see if it's faster again:

Uh, before I do that... I see a discrepancy in the code:

#+BEGIN_SRC elisp
  (setq matching-positions-in-node
        (cl-loop initially (goto-char node-beg)
                 while (re-search-forward positive-re node-end t)
                 collect (line-beginning-position) into result
                 do (end-of-line)
                 finally return (sort (delete-dups result) '<)))
  
  ;; Get list of line-strings containing any token
  ;; (setq matching-lines-in-node
  ;;       (cl-loop for pos in matching-positions-in-node
  ;;                do (goto-char pos)
  ;;                ;; Get text of each matching line
  ;;                for string = (buffer-substring-no-properties (line-beginning-position)
  ;;                                                             (line-end-position))
  ;;                unless (org-at-heading-p) ; Leave headings out of list of matched lines
  ;;                ;; (DISPLAY . REAL) format for Helm
  ;;                collect `(,string . (,buffer ,pos))))
  (setq matching-positions-in-node
        (cl-loop for token in input
                 do (goto-char node-beg)
                 while (re-search-forward (helm-org-rifle-prep-token token) node-end t)
                 collect (line-beginning-position) into result
                 do (end-of-line)
                 finally return (sort (delete-dups result) '<)))
#+END_SRC 

Somehow I put two of these loops in while commenting out the =matching-lines-in-node= part.  So running that loop twice could explain the slowdown...but then how were any context lines being displayed at all?  Wow...how did I manage to do that...  Oh I think I see, when I was testing the other =matching-positions-in-node= loop, I commented out and replaced the wrong one.  So...let's fix that and profile again:

#+CALL: context-fixed-test[]()

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       50          25.136648485  0.5027329696
re-search-forward                                             81250       9.2580263800  0.0001139449
org-heading-components                                        9750        2.3233045519  0.0002382876
helm-org-rifle-fontify-like-in-org-mode                       950         1.8861932009  0.0019854665
org-back-to-heading                                           11650       1.5047206050  0.0001291605
outline-back-to-heading                                       11650       1.4730061889  0.0001264382
goto-char                                                     38500       1.3475950079  3.500...e-05
s-matches?                                                    52300       1.2050915929  2.304...e-05
outline-next-heading                                          11700       1.0363664480  8.857...e-05
helm-org-rifle-prep-token                                     19400       0.9003198629  4.640...e-05
outline-previous-heading                                      9750        0.6790285010  6.964...e-05
re-search-backward                                            13950       0.6644822260  4.763...e-05
line-beginning-position                                       20850       0.4335685669  2.079...e-05
outline-on-heading-p                                          23050       0.3818343959  1.656...e-05
line-end-position                                             10450       0.3660547069  3.502...e-05
string-match                                                  74450       0.3551845139  4.770...e-06
org-indent-refresh-maybe                                      1900        0.3207771170  0.0001688300
buffer-substring-no-properties                                30250       0.2616993640  8.651...e-06
org-indent-add-properties                                     1900        0.2569457650  0.0001352346
org-at-heading-p                                              11400       0.2390862280  2.097...e-05
#+end_example

Okay, that is slightly faster, but this matches substrings, which I don't want.  So if I kept this, it would be a slight improvement over the current master in that it would fix the context matching while being a little bit slower.

I wonder if I could compromise and match substrings but only at the beginning of words (or after punctuation).  That could be useful anyway, because it would avoid the "did I use a plural" problem.  Let's see if I can try it...

Wait, if I do that, it might mess up the tags matching that took so long to fix.

I wonder if I should separate out the tags matching.  I already have it getting a list of tags in a separate string.  If I removed tags-matching tokens from the input and matched them separately, maybe it would let me use a simpler regexp for everything else and avoid the prep function.  I should probably make another branch to test that idea...sigh.  And I don't even know if that would improve performance.  I'd have to first separate out the tags matching, then verify that it works properly, and then simplify the main =positive-re= regexp, and then see if it is faster.

I think I'm going to stop here.  It seems to work properly right now: context-matching, tag-matching, avoids substring matches, and negation works.  And it seems fast enough, even if it is slower than before.  Maybe there is some combination of these changes that makes everything work at about the same speed as before, but I think trying to figure it out is too complicated with this big candidates-getting function.  I think it would be better to settle on this code that works correctly, and then go back to the =next-gen= branch and try to improve that, which is structured in a simpler way.

[2016-04-02 Sat 02:21] I decided to test in the MELPA sandbox before merging with master and pushing, and it's a good thing I did, because I discovered another weird bug: if the =show-tags= setting is off, the results are way off.  Probably a simpleish logic error in the code somewhere...but I think at this point I should just remove that setting.  As it is it's off by default, and I wonder how many people have gotten bad results because of it and decided that this package is no good.  I doubt anyone would want it off anyway, and it doesn't seem to hurt performance.  So let's just remove that so it's consistent...
* Plans

** TODO Search files instead of buffers

e.g search agenda files, or files in a directory.  Maybe write a =with-unopened-file= macro (or something like that) to =find-buffer-visiting= or =find-file-noselect=, and close the buffer afterward if it wasn't already open.

** TODO Match tags separately

This would probably make it simpler and faster.  Rather than trying to match a tags token across the entire node, it could just be matched against the tags string.  Could probably do away with the complex and confusing tags regexp matching and simplify the prep-token function.

** TODO Case-sensitive if caps are present

It would be easy to disable case-folding if caps are present in the search string.

** TODO Substring matching

Does searching for "solution" match this subheading?

#+BEGIN_SRC elisp
(helm-org-rifle-get-candidates-in-buffer (get-file-buffer "test.org") "solution")
#+END_SRC

...No, it does not.  That will probably need to be an option, customizable and/or with a prefix arg.

*** Test entry

Solutions

*** DONE [#A] Weird heading-only, second-word substring matching
CLOSED: [2016-04-02 Sat 04:48]
:LOGBOOK:
- State "DONE"       from "TODO"       [2016-04-02 Sat 04:48] \\
  This seems to be fixed now.
:END:

[[https://www.reddit.com/r/emacs/comments/4c4fpo/helmorgrifle_rifle_through_your_org_files/d1hdoop][From /u/washy9999]]:

#+BEGIN_QUOTE
incidentally, on the matter of searching for substrings... if i enter a single word to search for i get a results list. if i then start entering a second word helm filters the results for each character that i enter. so, i get substring searches for words after the first! (this is for headings...it gets more complicated if i do searches that return topic content.)
#+END_QUOTE

Hm, this is strange.  I'll have to check on it.

*** TODO Broken again

Now it's /doing/ substring matching again.  I specifically tested this earlier and it was working correctly, not matching substrings.  Now it's doing it again.  What.

** MAYBE Use grep to find matching lines

It might be faster, especially for unopened files, to use =grep -b= to get matching lines in a file, and then backtrack to find the node's heading, and then search the node.

** TODO Look at how [[https://github.com/jrblevin/deft][Deft]] searches files

It probably has some good techniques for doing it quickly.

** MAYBE flx sorting
[[https://github.com/abo-abo/swiper/issues/207][This swiper issue]] may have some good info about caching and such.  It might be too slow for rifle, or at least it might be too slow with lots of results.  Hmm...

** MAYBE Match only headings

It might be nice to only match against headings, but this is not as easy as it might seem.  This whole package is made to search both headings and content.

This Org function might make this fairly easy: =org-goto-local-search-headings=

** MAYBE Testing with [[https://github.com/jorgenschaefer/emacs-buttercup][Buttercup]]

Could be good for testing e.g. negation, to make sure I don't break it.

** DONE Support new Helm with input-idle-delay

Thanks to [[https://github.com/emacs-helm/helm/issues/1454#issuecomment-204519216][Thierry's help]], this should help prevent flickering.  This will be available in Helm 1.9.4 or commits after [2016-04-01 Fri].

* Bugs

** TODO [#C] Negation-only error

If only a negation pattern is given, an error happens.  Not a big deal, doesn't interfere with anything, just change the pattern and it goes away.

** TODO [#B] helm-org-rifle tags matching

When matching multiple tags in a string, the order of the tags matters, e.g. =:website:Emacs= does not match entries that are tagged =:Emacs:website:= org =:website:something:Emacs:=.  Not a big deal, but would be nice to fix it.  I suppose it could be useful to have this behavior, because the tags can always be specified separately, but it might be unexpected for it to work this way.

* Checklists
:PROPERTIES:
:LOGGING:  nil
:END:

** Stable release 1.2.0

*** DONE Try to get someone else to test it

Got some good feedback from Jack and zeltak, seems to be working well.

*** DONE Set =Version:= header

Use =x.y.0=, not =x.y=.

**** DONE =helm-org-rifle.el=

**** DONE =README.org=

*** DONE Update changelog

*** DONE Test in clean MELPA sandbox

**** DONE Update test checklist from changelog for new features

**** DONE Install

**** DONE Test functionality:

***** DONE Positive terms

***** DONE Negation

***** DONE TODO keywords

***** DONE Priorities

***** DONE Tags

****** DONE Positive

****** DONE Negative

****** DONE Multiple tags

****** DONE Multiple tags in a single string
e.g. =:tag1:tag2:=

******* DONE Positive

******* DONE Negative

***** DONE Context

***** CANCELED Ellipses customization

Maybe in 1.3.

***** DONE Searching with show-path enabled

***** DONE =helm-org-rifle-files=

***** DONE =helm-org-rifle-directories=

*** DONE Tag, sign, and push tag

If a new minor version (not new patch version), make new =x.x= branch.  Then tag the new branch, using  =x.x.0= for the first release in a minor version branch, not =x.x=.

*** DONE GitHub release notes


** Stable release 1.1
:PROPERTIES:
:LOGGING:  nil
:ORDERED:  t
:END:

Hmm, that seems like a long list.  But I want stable releases to actually be stable.

*** CANCELED Try to get someone else to test it
I tried.
*** DONE Set =Version:= header
*** DONE Update changelog
*** DONE Test in clean MELPA sandbox
**** DONE Update test checklist from changelog for new features
**** DONE Install
**** DONE Test functionality:
***** DONE Positive terms
***** DONE Negation
***** DONE TODO keywords
***** DONE Priorities
***** DONE Tags
****** DONE Positive
****** DONE Negative
****** DONE Multiple tags
****** DONE Multiple tags in a single string 
(=:tag1:tag2:=)
******* DONE Positive
******* DONE Negative
***** DONE Context
***** CANCELED Ellipses customization

Pushing this back to 1.2.

*** DONE Tag, sign, and push tag

** Stable release template

Hmm, that seems like a long list.  But I want stable releases to actually be stable.

*** TODO Try to get someone else to test it

*** TODO Set =Version:= header

Use =x.y.0=, not =x.y=.

**** TODO =helm-org-rifle.el=

**** TODO =README.org=

*** TODO Update changelog

*** TODO Test in clean MELPA sandbox

**** TODO Update test checklist from changelog for new features

**** TODO Install

**** TODO Test functionality:

***** TODO Positive terms

***** TODO Negation

***** TODO TODO keywords

***** TODO Priorities

***** TODO Tags

****** TODO Positive

****** TODO Negative

****** TODO Multiple tags

****** TODO Multiple tags in a single string
e.g. =:tag1:tag2:=

******* TODO Positive

******* TODO Negative

***** TODO Context

***** TODO Ellipses customization

***** TODO Searching with show-path enabled

***** TODO =helm-org-rifle-files=

***** TODO =helm-org-rifle-directories=

*** TODO Tag, sign, and push tag

If a new minor version (not new patch version), make new =x.x= branch.  Then tag the new branch, using  =x.x.0= for the first release in a minor version branch, not =x.x=.

*** TODO GitHub release notes
