[[https://melpa.org/#/general][file:https://melpa.org/packages/general-badge.svg]]

[[https://github.com/noctuid/general.el][file:http://i.imgur.com/SXA66y7.png]]
#+BEGIN_QUOTE
A general is a leader. -- onioncheese
#+END_QUOTE

* About
~general~ provides a more convenient way to bind keys in emacs for both evil and non-evil users. ~general-define-key~ allows defining multiple keys at once, implicitly wrapping key strings with ~(kbd ...)~, having named prefix key sequences (like the leader key in vim), and more.

* Advantages Over Evil-Leader
- Does not depend on evil (these points apply to regular emacs keybindings)
- Allows an arbitrary number of prefix keys or "leaders" of any length
- Does not /require/ a prefix key
- Allows choosing the specific evil state(s) and keymap(s) to map keys in
- Allows deferring keybindings until the keymap exists (no need for ~eval-after-load~)
- Allows for buffer local keybindings
- Does not use a global minor mode
- For evil, wraps ~evil-define-key~ instead of weirdly re-implementing half of it
- Allows using a single function for all keybindings

* Basic Setup
** Non-evil
#+begin_src emacs-lisp
(require 'general)
(setq my-leader1 "C-c")

;; bind "C-c a" and "C-c b" globally
(general-define-key :prefix my-leader1
                    "a" 'some-command
                    "b" 'another-command)

;; or without a prefix
(general-define-key
 "C-c a" 'some-command
 "C-c b" 'another-command)

;; bind a key in a specific keymap (keymaps must be quoted)
(general-define-key :keymaps 'org-mode-map
                    "TAB" 'org-cycle)

;; if you prefer an explicit (kbd) or don't want (kbd) at all:
(setq general-implicit-kbd nil)
(general-define-key
 (kbd "C-c a") 'some-command
 (kbd "C-c b") 'another-command)
#+end_src
** Evil
#+begin_src emacs-lisp
(require 'general)
;; bind a key globally in normal state; keymaps must be quoted
(setq general-default-keymaps 'evil-normal-state-map)
;; bind j and k in normal state globally
(general-define-key
 "j" 'evil-next-visual-line
 "k" 'evil-previous-visual-line)

;; bind gj and gk
(general-define-key :prefix "g"
                    "j" 'evil-next-line
                    "k" 'evil-previous-line)

;; named prefix key
(setq my-leader1 ",")
(general-define-key :prefix my-leader1
                    "f" 'find-file)

;; a default prefix sequence
(setq general-default-prefix ",")
(general-define-key "f" 'find-file)

;; bind a key in multiple states
(general-define-key :keymaps 'org-mode-map
                    :states '(insert emacs)
                    "TAB" 'org-cycle)
#+end_src

Vim-like definitions:
#+begin_src emacs-lisp
(general-evil-setup)
(general-nmap "j" 'evil-next-visual-line
              "k" 'evil-previous-visual-line)
;; or to bind in both normal and visual state
(general-nvmap "j" 'evil-next-visual-line
               "k" 'evil-previous-visual-line)

;; all keywords arguments are still supported
(general-nmap :prefix "SPC"
              "p" 'helm-mini)

;; alternatively, for shorter names
(general-evil-setup t)
(nmap "j" 'evil-next-visual-line
      "k" 'evil-previous-visual-line)
#+end_src

If you want to bind the same commands with a different prefix key for insert and emacs state, you can specify =:non-normal-prefix= or set ~general-default-non-normal-prefix~. For example, this command will bind `SPC /` to swiper in normal and motion state and `M-SPC /` to swiper in emacs and insert state:
#+begin_src emacs-lisp
(general-define-key :states '(normal motion insert emacs)
                    :keymaps 'text-mode-map
                    :prefix "SPC"
                    :non-normal-prefix "M-SPC"
                    "/" 'swiper)
#+end_src

This also applies when binding keys in ~evil-insert-state-map~ and ~evil-emacs-state-map~.

General is flexible in allowing you to choose how you write things, so if the above would be something you'd use often, you could create a function with the above keyword arguments as defaults using ~evil-general-create-definer~ and write the definition like this:
#+begin_src emacs-lisp
(my-normal-and-insert-define-key "/" 'swiper)
#+end_src

* More Details
This package provides one main function, ~general-define-key~, for key definitions for both evil and non-evil users. If you do not like keyword arguments or would like to create your own key-defining functions, this package also allows for these things.
** Settings and Keyword Arguments
~general-implicit-kbd~ can be set to nil if you want to manually use ~(kbd "keys")~ or if you don't want to use kbd at all.

~general-default-prefix~, ~general-default-states~, and ~general-default-keymaps~ determine the defaults for the corresponding keyword arguments =:prefix=, =:states=, and =:keymaps=.. By default, there is no prefix or state (each is nil), and the keymap is ~(quote global)~. Each keymap can either be a quoted keymap or ~(quote global)~ or ~(quote local)~. When the keymap is 'local, the key will be bound only in the current buffer (see the heading below for more information). When the keymap is 'global, the key will be bound in the ~(current-global-map)~.

~general-default-states~ and ~general-default-keymaps~ can be lists or a single element, allowing the user to define keys for multiple evil states or keymaps simultaneously. This can be useful in certain situations to prevent redundant keybindings (e.g. you want to define the same keys for visual and normal state).

There is also a =:predicate= keyword for giving a condition under which a map should be active.

** Positional Argument Wrappers
When you're defining keys in specific keymaps and states, using positional arguments can be shorter. General has two macros that can basically act as drop-in replacements for ~define-key~ and ~evil-define-key~. They are ~general-emacs-define-key~ and ~general-evil-define-key~. These are simply wrappers for ~general-define-key~ that pass the positional arguments to the corresponding keywords. However, for compatibility with ~define-key~ and ~evil-define-key~, it is not necessary to quote a single keymap. When you specify multiple keymaps, the list should still be quoted. 

For example, the following are equivalent:
#+begin_src emacs-lisp
(general-define-key :keymaps 'org-mode-map
                    "TAB" 'org-cycle
                    "S-TAB" 'org-shifttab)
(general-emacs-define-key org-mode-map
  "TAB" 'org-cycle
  "S-TAB" 'org-shifttab)

;; equivalent with define-key 
(with-eval-after-load 'org-mode
  (define-key org-mode-map (kbd "TAB") 'org-cycle)
  (define-key org-mode-map (kbd "S-TAB") 'org-shifttab))
#+end_src

And the following are equivalent:
#+begin_src emacs-lisp
(general-define-key :states '(normal visual) :keymaps 'org-mode-map
                    "TAB" 'org-cycle)
(general-evil-define-key '(normal visual) org-mode-map
  "TAB" 'org-cycle)

;; equivalent with evil-define-key
(evil-define-key 'normal org-mode-map
  (kbd "TAB") 'org-cycle)
(evil-define-key 'visual org-mode-map
  (kbd "TAB") 'org-cycle)
#+end_src

The actual behavior of these two macros is the same as ~general-define-key~. You can still use ~general-define-key~'s keyword arguments after the positional arguments:
#+begin_src emacs-lisp
;; these are both valid
(general-emacs-define-key 'global
  :prefix "C-c"
  "/" 'swiper)

(general-evil-define-key 'normal 'org-mode-map
  :prefix ","
  "g" 'worf-goto)
#+end_src
** Notes for Evil Users
When =:states= is specified (or ~general-default-states~ is non-nil), ~general-define-key~ will act as a wrapper around ~evil-define-key~. This means that the following are equivalent:
#+begin_src emacs-lisp
(setq general-default-states 'normal)
(general-define-key
 "j" 'my-j)

(let ((keymap (current-global-map)))
  (evil-define-key 'normal keymap
    "j" 'my-j))
#+end_src

Note that the "standard" way to define global keybindings for an evil state is as follows:
#+begin_src emacs-lisp
(define-key evil-normal-state-map "j" 'my-j)
(define-key evil-visual-state-map "j" 'my-j)
(define-key evil-normal-state-map "k" 'my-k)
(define-key evil-visual-state-map "k" 'my-k)
#+end_src

These are the equivalent with general:
#+begin_src emacs-lisp
(general-define-key :keymaps '(evil-normal-state-map evil-visual-state-map)
                    "j" 'my-j
                    "k" 'my-k)
;; or 
(setq general-default-keymaps '(evil-normal-state-map evil-visual-state-map))
(general-define-key "j" 'my-j
                    "k" 'my-k)
;; or
(general-evil-setup)
(general-nvmap "j" 'my-j
               "k" 'my-k)
#+end_src

Note that keybindings made for normal state in the global map will override keybindings made for evil-normal-state-map.

** Binding Keys for Only the Current Buffer
Specifying ~:keymaps 'local~ will bind keys in the current buffer alone, which may be useful in rare cases. This is not the same as using ~local-set-key~ (which will set the key for the current buffer's major mode). It uses ~evil-local-set-key~ when an evil state is given or a function that creates a minor mode for the current buffer otherwise.

** Predicates
The user can use the ~:predicate~ keyword to specify a condition under which the map(s) should be active. For example:
#+begin_src emacs-lisp
(general-define-key :keymaps 'local
                    ;; \\' is the buffer end
                    :predicate '(looking-at "\\'")
                    "<right>" 'beginning-of-buffer)
#+end_src

~<right>~ will now behave normally except at the end of the buffer where it will jump to the beginning of the buffer. Note that with ~:predicate~, you can still only have a key bound once in a single keymap. If you want to have a key take a lot of different actions depending on conditions in a single keymap, you'll want to put those conditions directly in the command or use something like [[https://github.com/yuutayamada/mykie-el][mykie]] instead.

See [[http://endlessparentheses.com/define-context-aware-keys-in-emacs.html][this post]] for more information about how this works.

** Functions to Help With Key Definition
*** Simulating Keypresses
General provides a macro called ~general-simulate-keys~ that can be used to simulate a key sequence. In some cases, this can be used similarly to a keyboard macro, but it has some advantages. Unlike with a keyboard macro, prefix arguments will work for the command the key simulates. The key simulated does not have to correspond to the full key sequence for a command. In these cases [[https://github.com/justbur/emacs-which-key][which-key]] will show the keys bound under the simulated prefix. For example:
#+begin_src emacs-lisp
(general-nmap "SPC" (general-simulate-keys "C-c"))
#+end_src

~general-simulate-key~ can take an optional argument (for use with evil only) that will cause the keys to be simulated in emacs state. This allows something like the following to work:
#+begin_src emacs-lisp
(general-nmap "j" (general-simulate-keys "C-n" t))
#+end_src

The key section can also be replaced by a list of a command and keys (e.g. ~(general-simulate-keys (#'evil-delete "iw"))~). See the next section for a reasonable use case for this feature.

Also note that ~general-simulate-keys~ creates a named function with a docstring, so which-key and ~describe-key~ will work properly for keys bound to a command created with it. The automatically generated function name and docstring can be replaced with optional arguments:
#+begin_src emacs-lisp
(general-nmap "SPC" (general-simulate-keys
                     "C-c" t
                     "Simulate C-c in emacs state with SPC."
                     general-SPC-simulates-C-c))
#+end_src

Make sure that you don't bind a key to simulate itself (e.g. ~(general-emap "C-n" (general-simulate-keys "C-n" t))~) as it wouldn't do anything (and would cause an infinite loop).

*** Mapping Under Non-prefix Keys
This functionality is mainly targeted at evil users, but it could potentially be useful for non-evil users as well. In vim you can bind something like =cow= without a problem. With evil, =c= is bound to ~evil-change~, so you can't bind directly to =cow=. A workaround for this case is to bind a key in ~evil-operator-state-map~, but this won't work, for example, if you wanted to bind =ctb= or =cw= to something special. I've come up with a more general workaround, ~general-key-dispatch~. Consider the following example:
#+begin_src emacs-lisp
(general-nmap "c"
              (general-key-dispatch 'evil-change
                "ow" 'toggle-word-wrap
                "w" (general-simulate-keys ('evil-change "iw"))
                "tb" 'some-command
                "c" 'evil-change-whole-line))
(general-vmap "c" 'evil-change)
#+end_src

In this example, the function created will execute any of the mapped key sequences or fall back to ~evil-change~. For example, =ow= is mapped, so =cow= will run ~toggle-word-wrap~. On the other hand, =b= is not mapped, so =cb= will act the same as =cb= would by default. Like with ~general-simulate-keys~, this uses ~unread-command-events~ internally instead of a keyboard macro, so prefix arguments will still work (e.g. =2cb=). However, because evil handles =cc= differently (since =c= is not a motion), =c= must be explicitly bound to ~evil-change-whole-line~ to keep its behavior. In visual state, =c= is not actually bound by default will use the normal state command, so to keep =c= working the same in visual state, you should explicitly bind it to ~evil-change~.

Another thing to note is that you can't bind a key in the ~general-key-dispatch~ section to simulate the base key (in this case =c=). For this example, you cant't bind =w= to ~(general-simulate-keys "ciw")~. While this won't cause an infinite loop, it won't work either, so you have to use the command name instead.

Another possible use is to emulate vim's =imap=. For example, you can recreate the common =jk= to =<esc>= keybinding:
#+begin_src emacs-lisp
(general-imap "j"
              (general-key-dispatch 'self-insert-command
                "k" 'evil-normal-state))
#+end_src

One thing to note is that this will not time out, and =j= will only be inserted after the next keypress. For an alternate way to do this, you might want to look at [[https://github.com/vlevit/key-seq.el][key-seq.el]] and [[https://www.emacswiki.org/emacs/key-chord.el][key-chord.el]].

** Creating Extra Keybinding Functions (Advanced)
The primary purpose of this package is to provide a single function for key definitions that is simple and flexible. Most users probably won't want to use this functionality (apart from ~general-evil-setup~). However, if you would like more specific keybinding functions for certain prefixes, evil states, or keymaps, this package provides macros to generate these functions. 

The ~general-create-definer~ macro can create functions for more succinctly defining keys. This is basically the same as naming a function with different defaults. This is how the ~nmap~, ~vmap~, etc. functions are created:
#+begin_src emacs-lisp
(general-create-definer my-nmap :keymaps 'evil-normal-state-map)
(my-nmap "w" 'evil-forward-word-begin)
#+end_src

It can also be used to implement a command to always use a certain prefix without having to always specify it (like ~evil-leader~ does):
#+begin_src emacs-lisp
(general-create-definer my-leader1 :keymaps 'global :prefix "C-c")
;; bind "C-c o" to other-window
(my-leader1 "o" 'other-window)
#+end_src

The user could also set ~general-default-prefix~, ~general-default-state~, or ~general-default-keymap~ to a different value within a function to achieve a similar effect.
