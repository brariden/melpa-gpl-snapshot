* rpn-calc.el

プログラマ向け RPN 電卓

quick RPN calculator for hackers

** Screencast

[[img/screencast.gif]]

** Advantages

=rpn-calc= is designed to be a handy tool for daily programming
use. For example,

- =rpn-calc= uses popup instead of making a new window, and you don't
  need to move your eyes between the edit point and calc window.

- =rpn-calc= displays binary representation of numbers automatically,
  which may be useful for programmers.

- =rpn-calc= is easier to customize. You can add/remove some
  operators with just one or two lines of Emacs Lisp.

- You can push not only numbers but any Emacs Lisp objects to the
  stack, and you can apply any Lisp function to them. So =rpn-calc=
  can also be used as an interactive, RPN version of
  =eval-expression=.

See also "Other Features" section.

** Installation

Require this script

: (require 'rpn-calc)

and invoke with =M-x rpn-calc=.

** Tutorial

1. You can push objects by pressing =[SPC]= after entering an
   S-expression (try: =120[SPC]=). You can also enter more complex
   S-expressisons like =(1+ (point))=.

   Tip: in Emacs, =#xFF= = =#b11111111= = =255=

2. When you enter an operator name, top elements in the stack are
   popped and applied to the operator (try: =1[SPC]sin=). List of
   built-in operators are listed below. You can add some operators by
   setting variable =rpn-calc-operator-table=.

3. You can also enter a function symbol to call it (try:
   =10[SPC]'number-to-string[SPC]=). If the function accepts =&rest=
   arguments, all elements in the stack are passed (try:
   =10[SPC]20[SPC]30[SPC]'list[SPC]=). This behavior can be changed by
   setting =rpn-calc-apply-rest-args=.

** Built-in Operators

- math
  - + :: pop =y=, =x= and push =(+ x y)=
  - -- :: pop =y=, =x= and push =(- x y)=
  - / :: pop =y=, =x= and push =(/ x y)=
  - * :: pop =y=, =x= and push =(* x y)=
  - % :: pop =y=, =x= and push =(mod x y)= (modulo)
  - sin :: pop =x= and push =(sin x)= (sine)
  - cos :: pop =x= and push =(cos x)= (cosine)
  - tan :: pop =x= and push =(tan x)= (tangent)
  - ln :: pop =x= and push =(log x)= (natural log)
  - lg :: pop =x= and push =(log x 10)= (log base 10)
  - log :: pop =y=, =x= and push =(log y x)= (log base x)

- bitwise
  - & :: pop =y=, =x= and push =(logand x y)= (bitwise and)
  - | :: pop =y=, =x= and push =(logor x y)= (bitwise or)
  - ^ :: pop =y=, =x= and push =(logxor x y)= (bitwise xor)
  - ~ :: pop =x= and push =(lognot x)= (bitwise not)
  - << :: pop =y=, =x= and push =(ash x y)= (shift left)
  - >> :: pop =y=, =x= and push =(ash x (- y))= (shift right)

- int <-> float
  - float :: pop =x= and push =(float x)= (int -> float)
  - int :: pop =x= and push =(truncate x)= (float -> int)
  - trunc :: pop =x= and push =(truncate x)= (round toward zero)
  - floor :: pop =x= and push =(floor x)= (largest integer < x)
  - ceil :: pop =x= and push =(ceil x)= (smallest integer > x)
  - round :: pop =x= and push =(round x)= (nearest integer to x)

- other speical operators
  - : :: pop =x=, and push =x= twice (duplicate)
  - \ :: pop =x=, =y= and push =y=, =x= (swap)

** Other Features

- Auto-committing

  If there seems no ambiguity, rpn-calc automatically commits the
  input after entering :

  - non-digit character after a number ::

       =1'1+[SPC]= is equivalent to =1[SPC]'1+[SPC]=.

  - outer-most closing paren ::

       =(1+ (point))= is equivalent to =(1+ (point))[SPC]=.

  - complete operator name ::

       =1sin= is equivalent to =1sin[SPC]=.

- Display binary representation of numbers

  When you push some numbers, their binary representation is
  displayed.

- Function quote

  You can quote function (tell rpn-calc not to call it) with function
  quote (=#'​=).

- Insert result to the buffer

  You can insert the result by pressing =RET=.

- Push items into middle of the stack.

  You can move cursor with =rpn-calc-next= (bound to =C-n= by default)
  and =rpn-calc-previous= (=C-p= resp.), to insert items into middle
  of the stack.

** Dependencies

- popup.el
